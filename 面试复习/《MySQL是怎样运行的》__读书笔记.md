# 《MySQL是怎样运行的》__读书笔记

## 第一章：重新认识MySQL

* MySQL支持的三种通讯方式：

  1. TCP/IP:

     3306

  2. 命名管道和共享内存：

     需要在同一台主机中，Windows系统

     * 命名管道：

       需要在启动服务器程序的命令中加上 --enable-named-pipe 参数，然后在启动客户端程序的命令中加入 -- pipe 或者 --protocol=pipe 参数。

     * 共享内存：

       需要在启动服务器程序的命令中加上 --shared-memory 参数，在成功启动服务器后， 共享内存 便成为本地 客户端程序的默认连接方式，不过我们也可以在启动客户端程序的命令中加入 --protocol=memory 参数来显 式的指定使用共享内存进行通信。

  3. Unix域套接字文件：

     ```
     如果我们的服务器进程和客户端进程都运行在同一台操作系统为类 Unix 的机器上的话，我们可以使用 Unix域套
     接字文件 来进行进程间通信。如果我们在启动客户端程序的时候指定的主机名为 localhost ，或者指定了 --
     protocol=socket 的启动参数，那服务器程序和客户端程序之间就可以通过 Unix 域套接字文件来进行通信了。
     MySQL 服务器程序默认监听的 Unix 域套接字文件路径为 /tmp/mysql.sock ，客户端程序也默认连接到这个
     Unix 域套接字文件。如果我们想改变这个默认路径，可以在启动服务器程序时指定 socket 参数，就像这样：
     mysqld --socket=/tmp/a.txt
     这样服务器启动后便会监听 /tmp/a.txt 。在服务器改变了默认的 UNIX 域套接字文件后，如果客户端程序想通
     过 UNIX 域套接字文件进行通信的话，也需要显式的指定连接到的 UNIX 域套接字文件路径，就像这样：
     mysql -hlocalhost -uroot --socket=/tmp/a.txt -p
     这样该客户端进程和服务器进程就可以通过路径为 /tmp/a.txt 的 Unix 域套接字文件进行通信了。
     
     ```



* 一个请求的流程：

  1. 连接管理：

     多线程 --> 线程池

     SSL安全层

  2. 解析与优化：

     1. 查询缓存：

        * 相同请求可以直接从缓存中查询结果
        * 任何字符上的不同都会导致不能命中
        * 如果涉及到的表中结构或者数据被修改，也不能使用缓存

     2. 语法解析：

        本质上是编译过程，涉及到词法解析、语法、语义分析

        将要查询的表、各种查询条件都提取出来放到MySQL服务器内部使用的数据结构中去

     3. 查询优化

        为提升效率，将查询语句优化：

        生成一个更高效率的查询计划

  3. 存储引擎：

     封装了数据的存储和提取操作

     ```
     我们知道 表 是由一行一行的记录组成的，但这只是一个逻辑上的概
     念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是 存储引擎 负责
     的事情。为了实现不同的功能， MySQL 提供了各式各样的 存储引擎 ，不同 存储引擎 管理的表具体的存储结构
     可能不同，采用的存取算法也可能不同。
     ```

     

##  第2章 MySQL的调控按钮-启动选项和系统变量

**暂略部分**





##  第4章 从一条记录说起-InnoDB记录结构

* 真实数据在不同存储引擎中存放的格式一般是不同的

* InnoDB页简介

  ```
  InnoDB 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小
  一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB
  内容刷新到磁盘中。
  ```

* InnoDB行格式：

  ```
  设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、
  Dynamic 和 Compressed 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理
  上大体都是相同的。
  ```

  * Compact

    ![img](《MySQL是怎样运行的》__读书笔记.assets/企业微信截图_1616400526476.png)

  ```
  这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是 变长字段
  长度列表 、 NULL值列表 和 记录头信息
  ```

  ```
  我们知道 MySQL 支持一些变长的数据类型，比如 VARCHAR(M) 、 VARBINARY(M) 、各种 TEXT 类型，各种 BLOB 类
  型，我们也可以把拥有这些数据类型的列称为 变长字段 ，变长字段中存储多少字节的数据是不固定的，所以我
  们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 MySQL 服务器搞懵，所以
  这些变长字段占用的存储空间分为两部分：
  1. 真正的数据内容
  2. 占用的字节数
  在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长
  字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！
  变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度
  是不储存的 。
  ```

  ```
  我们知道表中的某些列可能存储 NULL 值，如果把这些 NULL 值都放到 记录的真实数据 中存储会很占地方，所
  以 Compact 行格式把这些值为 NULL 的列统一管理起来，存储到 NULL 值列表中，它的处理过程是这样的：
  1. 首先统计表中允许存储 NULL 的列有哪些。
  2. 如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储 NULL 的列对应一个
  二进制位，二进制位按照列的顺序逆序排列，
  3. MySQL 规定 NULL值列表 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节
  的高位补 0
  ```

* 记录的真实数据

  ```
  对于 record_format_demo 表来说， 记录的真实数据 除了 c1 、 c2 、 c3 、 c4 这几个我们自己定义的列的数据
  以外， MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ），具体的列如下：
  DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row
  _id、transaction_id和roll_pointer。
  
  
  这里需要提一下 InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则
  选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为
  row_id 的隐藏列作为主键。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id
  和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。
  这些隐藏列的值不用我们操心， InnoDB 存储引擎会自己帮我们生成的。
  
  ```







## 第五章 盛放记录的大盒子-InnoBD数据页结构

* 在一个数据页中查找指定主键值的记录过程分为两步：

  ```
  1. 通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。
  2. 通过记录的 next_record 属性遍历该槽所在的组中的各个记录
  ```

* 总结：

  ```
  1. InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做 数据页 。
  2. 一个数据页可以被大致划分为7个部分，分别是
  File Header ，表示页的一些通用信息，占固定的38字节。
  Page Header ，表示数据页专有的一些信息，占固定的56个字节。
  Infimum + Supremum ，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的 26 个字节。
  User Records ：真实存储我们插入的记录的部分，大小不固定。
  Free Space ：页中尚未使用的部分，大小不确定。Page Directory ：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插
  入的记录越多，这个部分占用的空间越多。
  File Trailer ：用于检验页是否完整的部分，占用固定的8个字节。
  3. 每个记录的头信息中都有一个 next_record 属性，从而使页中的所有记录串联成一个 单链表 。
  4. InnoDB 会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个 槽 ，存放在
  Page Directory 中，所以在一个页中根据主键查找记录是非常快的，分为两步：
  通过二分法确定该记录所在的槽。
  通过记录的next_record属性遍历该槽所在的组中的各个记录。
  5. 每个数据页的 File Header 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个 双链表 。
  6. 为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时
  对应的 LSN 值，如果首部和尾部的校验和和 LSN 值校验不成功的话，就说明同步过程出现了问题。
  
  ```

  

## 第6章 快速查询的秘籍-B+树索引

* 所谓索引就是为了快捷查找而建立的目录

* B+树中页（节点分成两种）：

  ```
  目录项记录 的 record_type 值是1，而普通用户记录的 record_type 值是0。
  目录项记录 只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，
  另外还有 InnoDB 自己添加的隐藏列。
  还记得我们之前在唠叨记录头信息的时候说过一个叫 min_rec_mask 的属性么，只有在存储 目录项记录 的页
  中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。
  
  ```

* 查找方式：

  ```
  1. 确定 目录项记录 页
  我们现在的存储 目录项记录 的页有两个，即 页30 和 页32 ，又因为 页30 表示的目录项的主键值的范围是
  [1, 320) ， 页32 表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目录项记录在 页30
  中。
  2. 通过 目录项记录 页确定用户记录真实所在的页。
  在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了，不赘述了～
  3. 在真实存储用户记录的页中定位到具体的记录。
  
  ```

* 聚簇索引

  ```
  1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
      页内的记录是按照主键的大小顺序排成一个单向链表。
      各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
      存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成
      一个双向链表。
  2. B+ 树的叶子节点存储的是完整的用户记录。
      所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。
  我们把具有这两种特性的 B+ 树称为 聚簇索引 ，所有完整的用户记录都存放在这个 聚簇索引 的叶子节点处。这
  种 聚簇索引 并不需要我们在 MySQL 语句中显式的使用 INDEX 语句去创建（后边会介绍索引相关的语句），
  InnoDB 存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在 InnoDB 存储引擎中， 聚簇索引 就是数
  据的存储方式（所有的用户记录都存储在了 叶子节点 ），也就是所谓的索引即数据，数据即索引。
  
  ```

* 二级索引

  ```
  这个 B+ 树与上边介绍的聚簇索引有几处不同：
  使用记录 c2 列的大小进行记录和页的排序，这包括三个方面的含义：
  页内的记录是按照 c2 列的大小顺序排成一个单向链表。
  各个存放用户记录的页也是根据页中记录的 c2 列大小顺序排成一个双向链表。
  存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的 c2 列大小顺序排
  成一个双向链表。
  B+ 树的叶子节点存储的并不是完整的用户记录，而只是 c2列+主键 这两个列的值。
  目录项记录中不再是 主键+页号 的搭配，而变成了 c2列+页号 的搭配。
  
  所以如果我们现在想通过 c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个 B+ 树了。以查找 c2 列的
  值为 4 的记录为例，查找过程如下：
  1. 确定 目录项记录 页
  根据 根页面 ，也就是 页44 ，可以快速定位到 目录项记录 所在的页为 页42 （因为 2 < 4 < 9 ）。
  2. 通过 目录项记录 页确定用户记录真实所在的页。
  在 页42 中可以快速定位到实际存储用户记录的页，但是由于 c2 列并没有唯一性约束，所以 c2 列值为 4 的
  记录可能分布在多个数据页中，又因为 2 < 4 ≤ 4 ，所以确定实际存储用户记录的页在 页34 和 页35 中。
  3. 在真实存储用户记录的页中定位到具体的记录。
  到 页34 和 页35 中定位到具体的记录。
  4. 但是这个 B+ 树的叶子节点中的记录只存储了 c2 和 c1 （也就是 主键 ）两个列，所以我们必须再根据主键
  值去聚簇索引中再查找一遍完整的用户记录。
  
  
  ```

* 联合索引

  ```
  我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让 B+ 树按照 c2
  和 c3 列的大小进行排序，这个包含两层含义：
  先把各个记录和页按照 c2 列进行排序。
  在记录的 c2 列相同的情况下，采用 c3 列进行排序
  
  如图所示，我们需要注意一下几点：
  每条 目录项记录 都由 c2 、 c3 、 页号 这三个部分组成，各条记录先按照 c2 列的值进行排序，如果记录
  的 c2 列相同，则按照 c3 列的值进行排序。
  B+ 树叶子节点处的用户记录由 c2 、 c3 和主键 c1 列组成。
  千万要注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思
  与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：
  建立 联合索引 只会建立如上图一样的1棵 B+ 树。
  为c2和c3列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立2棵 B+ 树。
  
  ```




* MyISAM 中数据一张表，索引一张表，索引是索引，数据是数据



##  第7章 好东西也得先学会怎么用-B+树索引的使用

* 索引的代价：

  ```
  空间上的代价
  这个是显而易见的，每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，
  一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那可是很大的一片存储空间呢。
  时间上的代价
  每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。而且我们讲过， B+ 树每层节点都
  是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录
  （也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而
  增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页
  面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都
  要进行相关的维护操作，这还能不给性能拖后腿么？
  
  
  所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好
  又少的索引，我们先得学学这些索引在哪些条件下起作用的。
  
  ```

* B+树索引的适用条件：

  ```
  1. 全值匹配
  2. 匹配左边的列
  3. 匹配列前缀
  4. 匹配范围值
  5. 精确匹配某一列并范围匹配另外一列（其实是适用于联合索引并且where条件都恰好的情况）
  6. 用于排序（order by 后面的序列，也需要符合联合索引的顺序）
  ```

* 回表的代价：

  ```
  1. 会查询两个B+树，一个二级索引， 一个聚簇索引
  2. 访问二级索引使用顺序I/O, 访问聚簇索引使用随机I/O
  ```

* 覆盖索引：

  ```
  在查询列表里只包含索引列。
  ```

  ### 如何挑选索引

  1. 只为用于搜索、排序或分组的列创建索引

  2. 考虑列的基数

  3. 索引列的类型尽量小

  4. 索引字符串值的前缀

  5. 让索引列在比较表达式中单独出现：

     如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出 现的话，是用不到索引的

  6. 主键插入顺序

  7. 冗余和重复索引

##  第8章 数据的家-MySQL的数据目录

MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也都会存储 到这个目录下的某些文件中，这个目录就称为 数据目录 。







## 第19章 从猫爷被杀说起（事务）

* Begin commit rollback

* 默认为自动提交：

  ```
  默认情况下，如果我们不显式的使用 START TRANSACTION 或者 BEGIN 语句
  开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的 自动提交 。
  ```

* 隐式提交

  ```
  当我们使用 START TRANSACTION 或者 BEGIN 语句开启了一个事务，或者把系统变量 autocommit 的值设置为 OFF
  时，事务就不会进行 自动提交 ，但是如果我们输入了某些语句之后就会 悄悄的 提交掉，就像我们输入了
  COMMIT 语句了一样，这种因为某些特殊的语句而导致事务提交的情况称为 隐式提交 ，这些会导致事务隐式提交
  的语句包括：
  ```

  * 定义或修改数据库对象的数据定义语言（Data definition language，缩写为： DDL ）。
  * 隐式使用或修改 mysql 数据库中的表
  * 加载数据的语句
  * 事务控制或关于锁定的语句
  * 关于 MySQL 复制的一些语句
  * 其它的一些语句

* savepoint:

  保存点







## 第20章 说过的话就一定要办到-redo日志（上）

* redo日志：

  redo日志记录每次提交对数据表的变动

  * 特性：
    1. 占用的空间很小
    2. redo日志是顺序写入磁盘的







## 第22章 后悔了怎么办-undo日志（上）

* undo日志：

  在修改表中记录的时候，按照时间（事务id）为这些操作之前准备一个备份，以备不时的回滚需求