# 偏具体业务和杂项

### 1. 单点登录

* 单点登录，就是在多个系统中，用户只需要登录一次，各个系统即可感知到该用户已经登录
* 场景是分布式情况下，子系统的session不共享的问题。
  * 解决方法有：
    1. session全局同步——影响集群性能
    2. session信息放在redis中——可行
  * 单点登录方法：设立一个专门的登录系统，作为一个子系统。
* 具体方案：
  * SSO系统生成一个token， 并将用户信息存到Redis中，设置过期时间
  * 其他系统请求SSO系统进行登录，得到SSO返回的token，写到Cookie中。
  * 每次请求时，带上cookie，拦截器得的token，判断是否已经登录
* 新问题：cookie是不能跨域的，因为域名不同，cookie带不了，所以会有问题
  * 解决方法：
    * 客户端拿到cookie后，直接对cookie进行解析，取到其中的token，在其他请求的时候都带上这个token，就好了。不用移动要传递cookie
    * 多个域名共享cookie——cookie在写入到客户端时，直接设置cookie的domain，设置成若干个域名。
    * 将token保存在sessionstroage中，其实和方法一一样，不依赖cookie



### 2. CAP

* 评价分布式系统性能的一个理论
  * C: consistency， 数据一致性，分布的各个节点拥有相同版本的数据
  * A：availability,  可用性， 数据具备高可用性
  * P ：partition - tolerance  分区容错性， 容忍网络出现分区，分区之间网络不可达
* 在网络不可靠的前提下，要么CP， 要么AP，既然是分布式系统，作为核心的P是肯定要有的







### 3. BIO、 NIO、AIO

所有语言的I/O都是调用操作系统的接口，这里的BIO、NIO、AIO实质上是java下的概念，区别于select、poll、epoll，那是linux下的概念。

* 内核IO交互：
  1. 网卡收到经过网线传来的网络数据，并将网络数据写到内存（内核？）中。
  2. 当网卡把数据写入到内存（内核）后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。
  3. 将内存（内核）中的网络数据写入到对应socket的接收缓冲区（用户空间）中。
  4. 当接收缓冲区的数据写好之后，应用程序开始进行数据处理
* 同步 & 异步
  * 同步指的是调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。即方法二一定要等到方法一执行完成后才可以执行。
  * 异步指的是调用立刻返回，调用者不必等待方法内的代码执行结束，就可以继续后续的行为。（具体方法内的代码交由另外的线程执行完成后，可能会进行回调）。即执行方法一的时候，直接交给其他线程执行，不由主线程执行，也就不会阻塞主线程，所以方法二不必等到方法一完成即可开始执行。
  * 同步与异步关注的是方法的执行方是主线程还是其他线程，主线程的话需要等待方法执行完成，其他线程的话无需等待立刻返回方法调用，主线程可以直接执行接下来的代码。
* 阻塞与非阻塞
  * 阻塞与非阻塞指的是单个线程内遇到同步等待时，是否在原地不做任何操作。
  * 阻塞指的是遇到同步等待后，一直在原地等待同步方法处理完成。
  * 非阻塞指的是遇到同步等待，不在原地等待，先去做其他的操作，隔断时间再来观察同步方法是否完成。

* BIO

  BIO全称是Blocking IO，是JDK1.4之前的传统IO模型，本身是**同步阻塞模式**。 线程发起IO请求后，一直阻塞IO，直到缓冲区数据就绪后，再进入下一步操作。针对网络通信都是一请求一应答的方式，虽然简化了上层的应用开发，但在性能和可靠性方面存在着巨大瓶颈，试想一下如果每个请求都需要新建一个线程来专门处理，那么在高并发的场景下，机器资源很快就会被耗尽。

* NIO

  NIO也叫Non-Blocking IO 是**同步非阻塞**的IO模型。线程发起io请求后，立即返回（非阻塞io）。同步指的是必须等待IO缓冲区内的数据就绪，而非阻塞指的是，用户线程不原地等待IO缓冲区，可以先做一些其他操作，但是要定时轮询检查IO缓冲区数据是否就绪。Java中的**NIO 是new IO**的意思。其实是NIO加上IO多路复用技术。普通的NIO是线程轮询查看一个IO缓冲区是否就绪，而Java中的new IO指的是线程轮询地去查看一堆IO缓冲区中哪些就绪，这是一种IO多路复用的思想。IO多路复用模型中，将检查IO数据是否就绪的任务，交给系统级别的select或epoll模型，由系统进行监控，减轻用户线程负担。

  NIO主要有buffer、channel、selector三种技术的整合，通过零拷贝的buffer取得数据，每一个客户端通过channel在selector（多路复用器）上进行注册。服务端不断轮询channel来获取客户端的信息。channel上有connect,accept（阻塞）、read（可读）、write(可写)四种状态标识。根据标识来进行后续操作。所以一个服务端可接收无限多的channel。不需要新开一个线程。大大提升了性能。

  * 缓冲区buffer：

    buffer是一个对象，用来存储临时写入或需要读取的数据，实质上是一个字节数组，具体请款下可以是其他类型的数组

    - ByteBuffer：字节缓冲区
    - CharBuffer:字符缓冲区
    - ShortBuffer：短整型缓冲区
    - IntBuffer：整型缓冲区
    - LongBuffer:长整型缓冲区
    - FloatBuffer：浮点型缓冲区
    - DoubleBuffer：双精度浮点型缓冲区

  * 通道channel

    * Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。
    * 通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。也由于全双工特性，比流更好的映射底层操作系统的API
      - FileChannel:是从文件中读取数据。
      - DatagramChannel:从UDP网络中读取或者写入数据。
      - SocketChannel:从TCP网络中读取或者写入数据。
      - ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。
    * 多路复用selector
    * Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。
    * Selector：选择器对象，通道注册、通道监听对象和Selector相关。
    * SelectorKey：通道监听关键字，通过它来监听通道状态。
    * **监听的事件有**
      - OP_ACCEPT: 接收就绪，serviceSocketChannel使用的
      - OP_READ: 读取就绪，socketChannel使用
      - OP_WRITE: 写入就绪，socketChannel使用
      - OP_CONNECT: 连接就绪，socketChannel使用

  

* AIO

  AIO是真正意义上的异**步非阻塞IO模型**。 上述NIO实现中，需要用户线程定时轮询，去检查IO缓冲区数据是否就绪，占用应用程序线程资源，其实轮询相当于还是阻塞的，并非真正解放当前线程，因为它还是需要去查询哪些IO就绪。而真正的理想的异步非阻塞IO应该让内核系统完成，用户线程只需要告诉内核，当缓冲区就绪后，通知我或者执行我交给你的回调函数。

  AIO可以做到真正的异步的操作，但实现起来比较复杂，支持纯异步IO的操作系统非常少，目前也就windows是IOCP技术实现了，而在Linux上，底层还是是使用的epoll实现的。

  



### 4. 函数回调

* 直观的感觉是函数外包，将本函数应该执行的动作，交给另一个函数执行，可以更加灵活的添加参数。让别人做实际的工作，同时添加一些别的指令。
* 回调函数是你写一个函数，让预先写好的系统来调用。你调用系统的函数，是直调。让系统调用你的函数，就是回调。但假如满足于这种一句话结论，是不会真正明白的。





### 5. 事件驱动

* 事件驱动编程通常只是用一个执行过程，CPU之间不是并发的，在处理多任务的时候，事件驱动编程是使用协作式处理任务，而不是多线程的抢占式。事件驱动简洁易用，只需要注册感兴趣的事件，在回调中设计逻辑就可以了。在调用的过程中，事件循环器（Event Loop）在等待事件的发生，跟着调用处理器。事件处理器不是抢占式的，处理器一般只有很短的生命周期。

* 优势：

  1. 大部分的应用场景中，事件驱动编程优于多线程编程，相对于多线程，事件驱动复杂度较低
  2. 事件驱动经常使用在i?o框架中，可以很好的实现i/O复用。很多高性能的框架I/O都是使用事件驱动：Netty， Mina， Node.js
  3. 易于调试。事件驱动只和事件有关，而不是内部调度。问题容易暴露

* 劣势：

  1. 如果处理器占用时间较长，那会阻塞应用程序的响应。
  2. 无法通过时间来维护本地状态，因为处理器必须返回。
  3. 通常在单CPU环境下，比多线程编程要快，因为没有锁的因素，没有线程切换的损耗。

* 事件循环器： 用于等待和发送消息和事件。linux下是epoll

* 事件循环器不断接受来自客户端（Client）的请求，事件循环器把请求转交给注册了某类事件的工作线程（Worker）处理：

  ![img](偏具体业务和杂项.assets/企业微信截图_16126844884558.png)

根据实现的方式不同，在网络编程中基于事件驱动主要有两种设计模式：Reactor和Proactor。

* Reactor

  * 和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，应用程序需要提供相应的接口并注册到Reactor上，如果相应的事件发生，Reactor将主动调用应用程序注册的接口，这些接口又称为“回调函数”

  * 有点：

    1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；

    2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；

    3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；

    4）可复用性，Reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；

、





### Netty

https://juejin.cn/post/6844903704668160008