 

## 写在前面

本人双非本科大三，专业是微电子科学与工程，学过一点点 Java，[项目]()是纯 CRUD [项目]()，未接触过 RPC [项目]()，下面是阿里四个部门的[面经]()，让大佬们见笑了

## 2.24 淘宝购物车预面 64 min (过)

1. 自我介绍

2. 学校的学习和实习的时间是怎么分配的?

3. 实习的[项目]()做了什么?遇到的难点?

4. 在实验室做的[项目]()遇到的难点?

5. JPA 和 MyBatis 的区别?讲一下对象字段映射的细节

6. MySQL 各种索引的一些差异

   * ```
     B-Tree:存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优
     劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照
     原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索
     引的行，而InnoDB则根据主键引用被索引的行。
     B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页
     到根的距离相同。图5-1展示了B-Tree索引的抽象表示，大致反映了
     InnoDB索引是如何工作的。MyISAM使用的结构有所不同，但基本思想
     是类似的。
     
     B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据
     适合的查询类型：
     1. 全值匹配
     2. 匹配最左前缀
     3. 匹配列前缀
     4. 匹配范围值
     5. 精确匹配某一列并范围匹配另外一列
     6. 只访问索引的查询
     ```

   * ```
     哈希索引
     哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
     无法用于排序与分组；
     只支持精确查找，无法用于部分查找和范围查找。
     InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
     ```

   * ```
     全文索引
     MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。
     
     查找条件使用 MATCH AGAINST，而不是普通的 WHERE。
     
     全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
     
     InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。
     
     #4. 空间数据索引
     ```

   * ```
     空间数据索引（R-Tree）
     MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。
     
     必须使用 GIS 相关的函数来维护数据。
     ```

   * 

7. 什么是聚簇索引?什么是非聚簇索引?

   * 聚簇索引：索引顺序和物理顺序一致，找到索引，就找到相关的所有记录。因为物理顺序只有一个，所以一张表的聚簇索引也只有一个

     ```
     实际存储的循序结构与数据存储的物理机构是一致的，所以通常来说物理顺序结构只有一种，那么一个表的聚簇索引也只能有一个，通常默认都是主键，设置了主键，系统默认就为你加上了聚簇索引，当然有人说我不想拿主键作为聚簇索引，我需要用其他字段作为索引，当然这也是可以的，这就需要你在设置主键之前自己手动的先添加上唯一的聚簇索引，然后再设置主键，这样就木有问题啦。
     ```

   * 非聚蔟索引：

     ```
     非聚集索引并不是在物理上排列数据,即索引中的逻辑顺序并不等同于表中行的物理顺序,索引是指向表中行的位置的指针,这些指针本身是有序的,通过这些指针可以在表中快速定位数据。
     
     由于非聚集索引数据存储时无序的，所以在非聚集索引中指针包含数据行在数据页中的偏移量。即指针由 数据页 + 数据行偏移量 组成。
     ```

8. Innodb 是怎么保证崩溃恢复能力的?(两阶段日志提交)

   * 有binlog和redo log，两阶段日志提交

     ```
     其中，binlog 可以给备库使用，也可以保存起来用于恢复数据库历史数据。它是实现在 server 层的，所有引擎可以共用。redo log 是 InnoDB 特有的日志，用来支持 crash-safe 能力。
     
     一个事务的执行流程，你在最后三步可以看到，redo log 先 prepare 完成，再写 binlog，最后才进入 redo log commit 阶段。
     上述可以概括为两阶段提交
     
     具体：奔溃发生在binlog写完，redo log 还没有commit的情况：
     规则：
     1. 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；
     2. 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：
     a. 如果是，则提交事务；
     b. 否则，回滚事务。
     
     这里，时刻 B 发生 crash 对应的就是 2(a) 的情况，崩溃恢复过程中事务会被提交。
     ```

     

9. Innodb的优缺点?(围绕索引数展开讲)

   * 优点： 支持奔溃回复

   * ```
     索引的优点
     大大减少了服务器需要扫描的数据行数。
     
     帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
     
     将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。
     
     #索引的使用条件
     对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
     
     对于中到大型的表，索引就非常有效；
     
     但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术
     ```

   * 

10. 索引覆盖?回表?唯一索引?非唯一索引?最左原则?

    * ```
      唯一索引
      如果确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候，就应该用关键字UNIQUE把它定义为一个唯一索引，Mysql会在有新纪录插入数据表时，自动检查新纪录的这个字段的值是否已经在某个记录的这个字段里出现过了。如果是，mysql将拒绝插入那条新纪录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复
      ```

    * ```
      回表查询：
      通俗的讲就是，如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表。
      ---
      也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。
      ```

    * ```
      覆盖索引：
      只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
      ---
      用自己的话总结，覆盖索引就是不需要回表的查询
      
      翻译过来就是， 要的查询结果就是主键值且查询条件就是非主键索引字段，即在索引树上的查询结果就是我们需要的结果。
      ```

    * ```
      最左匹配原则：
      因为B+树的结构，所以有最左前缀原则/最左匹配原则，意思就是，对于联合索引，只要查询条件与联合索引从左到右部分字段顺序相匹配，该次查询就可以利用联合索引进行加速。
      
      例如现有联合索引（x,y,z）
      
      如果查询条件是WHERE x=1 AND y=2 AND z=3；那么就是对该联合索引的完全匹配。
      
      如果查询条件是WHERE x=1 AND y=2；那么就是利用了该联合索引（符合最左匹配原则）
      
      当然，WHRER x=1;可以以利用该联合索引
      
      如果是WHERE y=2 AND z=3；或者 WHERE z=3；等，就无法利用联合索引（x,y,z）
      ```

    * 

11. explain 里面有哪些字段?

    * ```
      select_type : 查询类型，有简单查询、联合查询、子查询等
      key : 使用的索引
      rows : 扫描的行数
      id： 标识select所属的行，或者顺序
      table: 正在访问那个表
      type: MySQL用户手册上说这一列显示了“关联类型”，但我们认为更准确的说法是访问类型——换言之就是MySQL决定如何查找表中的行
      ```

12. 一个 SQL 查询很慢,从哪些地方进行优化?

    * 1. 切分查询，大查询切分成小查询
      2. 拆分Join。简单地，可以对每一 个表进行一次单表查询，然后将结果在应用程序中进行关联。

13. 自增 ID 和 UUID 的区别?(叶分裂)

    * 自增id有序，所以新添加的也是有序节点
    * UUID首先是无序的，插入时会有随机性，其次UUID一般长，在B+树中，会导致一个节点的索引（指针）太少，树的高度增加.在建立索引和基于索引进行查询时都存在性能问题。

14. 自增 ID 申请完了会发生什么事情?

    * ```
      MySQL自增id用完后，再次申请id，得到的值保持不变。插入数据会报主键冲突异常。
      MySQL InnoDB表未指定主键时，MySQL会指定一个row_id，如果row_id用完了，则会从头开始循环。从这点来说还是建议我们创建表的时候指定主键的，毕竟使用row_id会发生覆盖数据，导致原来的数据丢失，影响数据的可靠性。
      ```

15. 分库解决了什么问题?分表解决了什么问题?

    * ```
      1、随着单库中的数据量越来越大，相应的，查询所需要的时间也越来越多，相当于数据的处理遇到了瓶颈
      2、单库发生意外的时候，需要修复的是所有的数据，而多库中的一个库发生意外的时候，只需要修复一个库（当然，也可以用物理分区的方式处理这种问题）
      ```

16. 你觉得学 Java 需要具备哪些基本条件?哪些地方特别重要?

17. 七层网络模型

    * 物理层、数据链路层、网络、传输、会话、表示、应用

18. 为什么有了七层还有五层的概念?

    * 七层是理论，五层是实际

19. JVM 内存模型(概述)

    * ```
      线程资源：
      
      程序计数器：记录正在执行的虚拟机字节码指令的地址
      ---
      Java虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
      
      该区域可能抛出以下异常：
      
      当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
      栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。
      ---
      本地方法栈： 
      本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
      
      本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
      
      
      进程资源：
      堆：
      所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。
      
      现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：
      
      新生代（Young Generation）
      老年代（Old Generation）
      堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。
      
      ---
      方法区：
      用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
      
      和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
      
      对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
      方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。
      ```

20. 讲讲双亲委派,为什么?

    * 加载一个类，用低向上请求：（用户自定义类加载器）--》（应用程序类加载器）-->(扩展类加载器)  --> (启动类加载器)

    * 然后自顶向下，寻找各层的目录，找到类进行加载

    * 好处：

      使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

21. 你觉得双亲委派这个名字有没有什么问题?你讲讲自己的理解

    * 双亲的双字有迷惑性，应该是父级委派

22. 打破双亲委派的例子,举个例子?怎么打破?

    * 重写loadClass方法：

      ```
      默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。这里为了破坏双亲委派机制必须重写loadClass方法，即这里先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。
      ```

    * 例子：

      ```
      为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。
      ```

      

23. 你现在用什么 GC 收集器?

24. Eden 区的对象回收策略?

    * 复制算法

    * ```
      年轻代（或称新生代，Young、New）通常用来放新生成的对象（但不绝对，如可以通过-XX:PretenureSizeThreadshold配置将大对象直接分配在老年代）。年轻代的目标就是尽可能快速地收集掉那些生命周期短的对象。
      
      
      年轻代分3个区，1个Eden区，2个Survivor区（from 和 to），但每次只使用Eden和一个Survivor区，另一个Survivor区空着。空Survivor区用来放MinorGC时从Eden和在使用的Survivor区中复制来的活着的对象。
      
      
      针对年轻代的GC为Minor GC或称Young GC，在Eden剩余空间不足以分配新对象时触发
      
      ---
      生成对象（为对象分配内存）的过程如下：
      
      首先看Eden剩余空间是否足够分配该对象，若够则直接在Eden分配；
      否则进行MinorGC：将Eden和在使用的Survivor区中活着的对象复制到另一个Survivor区，并回收Eden和使用着的Survivor区。然后把对象分配到Eden，以后另一个Survivor成为使用的Survivor区；
      若另一个Survivor区不能完全容纳复制过来的对象，则能放下的放入该Survivor，把放不下的放到老年代（即进行分配担保）；
      若老年代剩余空间不够了则进行Full GC，
      若Full GC后仍不够则抛出OOM异常。
      
      具体可以分为：
      
      分配过程（优先在Eden分配）
      分配担保（垃圾回收时Survivor放不下的存活对象移到老年代）
      提前移动的配置（大对象、对象年龄、动态年龄）
      ```

25. CMS 的 STW 情况?

    * 初始标记，标记GC Root，速度快，但是需要停顿
    * 重新标记： 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿

26. CMS 什么情况会触发 Full GC?

    * ```
      1.System.gc()
      在没有开启DisableExplicitGC的情况下，虽然只是建议，但是很多情况下，都会调用Full GC的，比如在原本应进行CMS的时候。System.gc()一般都是用在要释放堆外内存的时候使用。
      
      2.老生代内存不足的时候
      这种情况通常是对象要晋升到老年代中时，发现老年代的内存不足了，所以要引发一次Full GC。对象的晋升分为正常晋升和提前晋升。
      
      3.永生区空间不足时
      有些虚拟机把方法区也放到堆中管理，当加载的类太多时，永生区内存不足需要回收，也会触发Full GC
      
      4.冒险失败之后
       在Minor GC时发现to去的内存不足，则将Eden区和from区的内存全部晋升到老年区，清空新生代。但是如果此时老年区内存不足，则会冒险失败，冒险失败之后，对象仍然留在新生代（此时的Eden区和from区都接近99%），然后出发一次Full GC，这样便于下次如果还有冒险，可以增加冒险成功的几率。
      
      5.HandlePromotionFailure设置为false或者历年平均晋升对象的大小大余老年代剩余连续空间
      在Minor GC之前，虚拟机会检查老年代剩余连续空间是否大余新生代所有对象总大小，如果大余，则说明Minor GC绝对安全；如果小于，则会检查HandlePromotionFailure设置是否担保失败，如果不担保，则在Minor GC之前进行一次Full GC；如果担保，则再检查历年平均晋升对象的大小是否大余老年代剩余连续空间，如果大余，则不冒险，在Minor GC之前进行一次Full GC；如果小于，则冒险，进入情况4。
      
      6.分配大对象时（和2其实是一样的，但是因为特殊，所以单独拿出来说）
      如果直接要分配一个大对象，并且这个大对象的大小超过Eden区的一半，这个对象就会直接分配在老年代，此时如果老年代空间不足，出发一次Full GC，而不出发Minor GC。但是需要注意的是，如果分配的是TLAB而不是真正的大对象，那么不会导致full gc，而是调整TLAB的大小。
      
      7.执行jmap -histo:live或者jmap -dump:live的时候
      这属于强制让虚拟机执行一次full GC。
      ```

      

    

    * ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg)

    * ```
      CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。
      
      分为以下四个流程：
      
      初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
      并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
      重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
      并发清除：不需要停顿。
      在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。
      
      具有以下缺点：
      
      吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
      无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
      标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
      #7. G1 收集器
      ```

    * 

27. 新对象一定会在新生代 new 出来么?

    * 未必，对象过大可能直接在永久代

28. Java8 有什么新的 GC [算法]()?

    * G1

29. 了解 G1 收集器么?

    ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg)

    ```
    G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。
    
    堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。
    
    
    G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。
    
    
    
    通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。
    
    每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。
    
    
    
    如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：
    
    初始标记
    并发标记
    最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
    筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。
    具备如下特点：
    
    空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
    可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。
    ```

    

30. 考研么?为什么现在的实习想离职了?

31. Golang 和 Java 的区别?

    * ```
      Java和Go都处理完全不同的壁垒。
      Go的指针仅限于数组和对象，它们可以提供指向任何类型的值的指针。
      Go不使用异常来显示运行时和寿命终止之类的事件，而是使用错误来显示此类事件。
      Go基本上被编译为机器代码。
      Java支持省略检查以处理和捕获错误。
      Go提供垃圾回收，但是像Java一样，它不支持完整的GC。
      Go上不允许函数重载，必须具有唯一的方法和函数名称。
      Java中没有原始的无符号数字类型，这就是Java不适合进行底层编程的原因。
      Java中的命名空间不告诉源文件位置。
      Go提供了内置数据类型（例如map和切片），以及一些通用功能（例如复制和追加等）。
      Java仅允许其中包含公共类的源文件。
      Go提供了在OS线程上运行的轻量级线程例程。
      Java 在最佳编程语言列表中排名第18 位，而Go排在第 8 位。
      Go支持复数，因为它对此具有内置支持。
      Java vs Go在多态性方面有不同的看法，Java默认情况下允许多态，而Go则不会。
      Go的API完全由Google处理。
      Java API由开放社区流程控制。
      Java默认使用虚拟方法。
      Java不允许运算符重载，这使其更轻松。
      ```

    * 

32. 反问:有什么需要提高的?

## 2.25 淘宝购物车一面 50 min (过)

1. 上一次面试问了些什么问题?

2. 啥时候过来实习?

3. 挑一两个你实习或者[项目]()当中遇到的难题?讲一讲怎么解决的?

4. [项目]()当中的代码你有没有想过有一些地方可以优化?

5. 哪些情况会出现 OOM?

6. 堆中内存分配比例?

7. 新生代 GC 工作流程?

8. 为什么新生代年龄是 15 次进入老年代?

9. 大对象进入老年代,这个大对象是有多大?

   * ```
     虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（复习一下：新生代采用复制算法收集内存）。
     所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。
     
     注意　PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。
     ---
     对象优先在新生代分配，但是有的情况对象直接在老年代分配，如下：
     
     1、分配的对象大小大于eden space。适合所有收集器。
     
     2、eden space剩余空间不足分配，且需要分配对象内存大小不小于eden space总空间的一半，直接分配到老年代，不触发Minor GC。适合-XX:+UseParallelGC、-XX:+UseParallelOldGC，即适合Parallel Scavenge。
     
     3、大对象直接进入老年代，使用-XX:PretenureSizeThreshold参数控制，适合-XX:+UseSerialGC、-XX:+UseParNewGC、-XX:+UseConcMarkSweepGC，即适合Serial和ParNew收集器。
     ————————————————
     版权声明：本文为CSDN博主「抱抱-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
     原文链接：https://blog.csdn.net/shi2huang/article/details/80092261
     ```

10. 怎么排查 OOM?

11. 你现在用过哪些中间件?

    * mysql & redis

12. RPC 了解么?

13. RPC 解决了现在的哪些问题?

14. 有没有想过把你的[项目]()改造成 RPC?

15. IOC 的初始化流程?

16. AOP是怎么和 IOC 做整合的?

17. 循环依赖怎么解决?

18. [项目]()怎么分层的?

19. JPA 和 MyBatis 做对象映射的区别?原理?

20. 数据库热点查询的数据,怎么做性能优化?

21. Innodb 的索引树数据结构?

22. 最左原则?

23. 有没有其他复杂的[项目]()?

24. 排查问题的手段,你目前知道哪些?

25. 讲讲你的优势?

## 3.04 钉钉一面 72 min (过)

1. 自我介绍
2. 介绍一下[项目]()和实习
3. 你对 RPC 的理解?
4. HTTP 和 RPC 的关系?区别?
5. RPC 的优点?
6. 任何一个请求过来都会打到注册中心么?
7. 关于[项目]()和实习的一些问题
8. HDFS 了解么?
9. Java 的流式处理了解么?
10. SpringMVC 处理请求的一个流程?
11. Servlet 的监听器和拦截器?
12. 有哪些方法可以拦截一个 HTTP 请求?
13. 关于接受请求的参数,你有没有一套自己总结的方法?
14. 在学校还做过哪些[项目]()?
15. 你觉得学 Java,最重要的是什么?
16. 你对 IOC 的理解?
17. AOP 的各种实现有什么差异?
18. 为什么会有多种代理的方式?
19. HTTPS 的秘钥交换过程?
20. 有中间人劫持则么办?
21. 双亲委派的理解?
22. 为什么有双亲委派?一定要遵循双亲委派么?
23. 怎么打破双亲委派?
24. 有一个线程要等待其他线程执行完再执行?
25. 有一个线程要等待其他线程都就绪再执行?
26. 顺序打印 ABC?
27. Innodb 索引的数据结构?为什么用 B+树?
28. 100 瓶药一瓶毒药.懂得都懂.
29. [海量数据]()取前 5.

## 3.04 业务中台一面 52 min (过)

1. 自我介绍

2. 有没有面其他的部门?

3. 介绍一下自己的实习[项目]()?

4. 关于[项目]()的一些问题

5. 你觉得实习做的事情还有没有什么可以优化的?

6. 为什么 TX 用 Golang?(我怎么知道?)

7. DNS 解析流程?

8. 怎样解析一个域名?解析一个域名需要哪些信息?

9. 为什么用 Nginx?

10. 你觉得 Nginx 在你的[项目]()中最大的作用是什么?

11. HTTPS 的秘钥交换过程?

12. 你觉得使用了 HTTPS 之后还会出现问题么?出现问题了怎么办?

13. 外挂的 Tomcat 和 SpringBoot 内嵌的 Tomcat 有什么区别?

14. Tomcat 的设计模式了解么?

15. SpringBoot 怎么调起Tomcat?

16. 你对 IOC 的理解?

17. 实际开发当中你哪些地方使用了 Bean 的前置后置处理器?

18. AOP 是怎么和 IOC 进行整合的?

19. Spring 怎么把 Java 对象初始化成 SpringBean 的?

20. HashMap 八股文讲讲?

21. 哪些情况下会产生 Full GC?

22. 方法区的大小怎么设置?

23. 栈大小怎么设置?

24. 你遇到过堆栈溢出的情况么?怎么解决的?

25. MySQl 主从集群怎么搞?

26. Binlog 有几种?区别是什么?

    * ```
      有三种格式，statement，row和mixed。
      
      statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
      row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
      mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
      ————————————————
      版权声明：本文为CSDN博主「猫巳」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
      原文链接：https://blog.csdn.net/qq_31635851/article/details/109599527
      ```

    * 

## 3.05 业务中台二面 75 min (过)

1. 面试官上来花了 10 分钟介绍了他们部门
2. 关于 Github 上面的[项目]()的问题(这个代码是大二上期写的)
3. [项目]()当中的数据库设计,你是怎么做的?
4. [项目]()怎么分层的?
5. 流量打到 SpringMVC 上面之后的处理流程?
6. 微信小程序登录的流程?
7. JS SDK 登录和后端请求微信服务器登录的区别?
8. 你觉得微信登录获得的 raw 信息可以被黑客劫持么?
9. 你使用过分表么?分库分表分别解决了什么问题?
10. 分表的时候,怎么设计主键?
11. 自己的[项目]()当中,用到自定义索引的情况?
12. 最左原则?联合索引?
13. 为什么会有最左匹配原则?(根据 B+树[排序]()规则去回答)
14. 为什么使用 B+树?回表?怎么减少回表?
15. 数据库的乐观锁和悲观锁?
16. 读锁和写锁的区别?
17. 假设现在有一个需求,需要在一个 for 循环里面连续 100 次去更新一个行记录,这个过程中会出现阻塞的情况?怎么使用编码的方式来规避这种情况?(手动继承 AQS)
18. 怎么关闭长事务?
19. 为什么想来阿里?
20. 微服务实例是怎么暂停的?了解么?
21. 关于实习和[项目]()的一些问题
22. 线程池 7 个参数的含义?
23. 线程池提交任务的流程?
24. 对分布式的了解有多少?

## 3.05 钉钉二面 50 min (过)

这轮面试忘了录音了,有些问题不记得了.

1. 关于[项目]()和实习的一些问题.
2. 一个分布式部署的[项目]()?至少需要哪些模块?
3. 任何一个流量打过来都会打到注册中心么?
4. 一个注册中心,至少需要具备哪些条件?
5. 有一大批流量总是被打到一个实例上面,这个实例的兄弟实例分到的流量很少,怎么办?
6. 有一个实例挂了怎么办?
7. 注册中心集群的时候,其中一个注册中心挂了怎么办?
8. 平时通过哪些渠道学习?
9. 看过哪些博客?
10. 你觉得[美团]()的博客上面有哪几篇对你帮助特别大?
11. 然后具体谈了谈这一篇博客
12. 你看视频一般在哪儿看?看那些类型的视频?
13. 能给我推荐一个关于技术的公众号么?
14. 你有看过阿里的一些技术博客么?你觉得他们写的博客对你有没有帮助?

剩下的八股文问题不记得了.....

## 3.05 淘宝购物车二面 60 min (过)

这一轮面试也忘了录音了....

1. 自我介绍
2. 关于[项目]()和实习的一些问题
3. HashMap put 里面已经有100000 个数据了,往里面 put 第 100001 个数据会不会扩容?
4. 你觉得采用[链表]()加[红黑树]()的组合方式之后解决了什么问题?
5. 那么多数据结构,为什么偏偏使用[红黑树]()?
6. [红黑树]()的平衡怎么做?
7. [链表]()转化成[红黑树]()的阈值怎么算出来的?
8. 为什么[红黑树]()缩回[链表]()的阈值和进化的阈值不一样?
9. 现在用编码的方式进行代码同步,有哪些方法?
10. 公平锁和非公平锁的实现(AQS 八股文)
11. volatile 的特性?
12. 一个 volatile 变量,一个线程写,多个线程读会不会出现线程不安全的问题?
13. IOC 的初始化流程?
14. Java 的类加载过程?
15. 为什么会有 TIMEWAIT这个状态?
16. 拥塞控制?流量控制?
17. 10000 亿条淘宝订单,每条订单当中包含了一个交易流水,流水里面有商品的 ID,有购买数量,同一个商品在这个订单会出现多次,现在要统计销量最好的 10 件商品.

能记起来的就这些.....

## 3.06 新零售场景金融一面 70 min (过)

1. 为什么不找硬件相关的实习来做软件?
2. 能给我介绍一下微电子科学与工程这个专业是干什么的么?
3. 你是怎么学习软件开发的这些东西?
4. 关于实习和[项目]()的问题
5. 讲讲面向对象的一些特性?
6. Java 7 大原则?
7. 面向过程和面向对象的区别?
8. 对象和类的关系?
9. Java 容器八股文
10. HashMap 八股文
11. 进程和线程的区别?
12. Java 创建线程的方式?
13. 线程池参数和任务提交到执行的过程?
14. 对于线程池参数的设定,你有没有自己的一套方案?
15. 代码的同步怎么做?
16. Java 的类加载过程?什么时候回触发到 Java 类的加载?什么时候回触发类的卸载?
17. 双亲委派?打破双亲委派?
18. 重载和重写在 JVM 层面是怎么鉴别的?
19. JVM当中的方法内联?
20. MySQL中的事务是怎么实现的?
21. 隔离级别的区别?都是怎么实现的?
22. 事务数组是什么?高水位指的是哪些?低水位指的是哪些?
23. Innodb 索引数据结构?阿巴阿巴
24. SQL 语句执行流程?分析器优化器执行器都是什么?
25. 回表?索引下推?
26. IOC 的初始化流程?
27. 为什么会有 SpringBoot 的出现?
28. 讲讲自动装配?
29. 你更倾向于 MyBatis 还是 JPA?
30. 这两个 ORM 的实现和区别?
31. 问[项目]()....
32. 问实习...
33. 你的大学生活,时间一般是怎样安排的?
34. 你觉得你自己的大学生活充实么?
35. 一般采用哪些方式学习?
36. B 端业务和 C 端业务你更倾向于哪种?

## 3.06 新零售场景金融二面 110 min (过)

1. 自我介绍
2. 本专业的成绩怎么样?
3. 挂过科么?为什么会挂科?能不能总结一下这一次挂科?
4. JVM内存模型概念?
5. 你对方法区/元空间的理解?
6. 堆中内存的分配?
7. 永久带会涉及到 GC 回收么?
8. 程序运行的时候,怎么监控内存使用情况?
9. 程序运行的时候,怎么看堆栈信息?
10. Java 类加载的过程?
11. 魔数是什么?
12. 为什么叫双亲委派?你有没有觉得这个名字怪怪的?
13. 在一个类中调用了另一个类的私有方法能不能通过编译?
14. ClassNotFoundException出现在哪些地方?
    * 类加载过程中
15. 假如说现在有一个 可执行的A.jar和 B.jar,他们都互相引用了对方,现在 B.jar 里面的某些类已经不在了,A还能启动么?
16. ldc,iconst,getstatic,ACC_FLAG 这几个指令都是什么意思?
17. IOC 的特性?你对 IOC 的理解?
18. 我们自己也可以实现 IOC 和 AOP,甚至是前置后置处理器,为什么还要用 Spring 提供的?
19. 怎样才能知道 Spring 的 IOC 容器已经完全初始化了?
20. 事件订阅的接口名字是什么?
21. 为什么我会问这个问题?为什么我们需要知道 Spring IOC 容器的初始化进度?
22. Spring 的后置处理器接口名字是什么?
23. AOP 和 IOC 的整合流程?
24. AOP 是怎么做动态代理的?
25. CGLIB 是怎么操作字节码的?
26. ASM 操作字节码的原理?
27. XML 的两种解析策略?两种有什么差异?
28. 线程池参数?
29. 任务提交到线程池之后会遇到哪些情况?
30. 用银行取钱的例子给我讲讲线程池?
31. sync 对应的字节码是什么?
32. sync 锁静态方法和非静态方法锁的分别是什么对象?
33. 为什么锁的对象不一样?
34. 为什么使用 Maven?
35. 一个 a.jar 引用了 c,版本是 1.0.0,b.jar 引用的 c 版本是 2.0.0,一个[项目]()当中同时依赖了a 和 b,这时候依赖的 c 版本是哪一个?为什么?
36. Maven 仲裁策略有几步?
37. 数据库的事务特性?
38. 隔离级别的差异?为什么会有这种差异?
39. 讲讲可重复读和读提交隔离级别和实现机制?
40. 什么是"当前读"?
41. 为什么[项目]()当中要使用缓存?
42. 为什么 Redis 这么快?
43. Redis的持久化机制?
44. 在生成 RDB 的过程当中,还能继续进行写入么?
45. 为什么 AOF 是数据先落盘再写日志?而数据库是先写日志再落盘?
46. 哨兵的选主策略?一个哨兵是怎么知道其他哨兵的存在的?
47. HashMap 八股文
48. [红黑树]()的特点?
49. 三次握手和四次挥手的过程?
50. TIMEWAIT 为什么要等待 2MSL?
51. 301 和 302 状态码的区别?
52. 磁盘调度[算法]()?
53. 操作系统死锁?
54. 进程和线程的区别?
55. 哪一种 IPC 最快?
56. 线程的几种状态?
57. 进程调度策略?
58. 三点十五分时针和分针的夹角?

## 3.07 业务中台三面 35min (过)

1. 自我介绍
2. 问[项目](),问实习
3. 你在[项目]()当中担任的角色?
4. 你觉得 TX 的氛围怎么样?
5. 你一般几点走?
6. 那边加班严重么?
7. RPC 调用过程中,现在要在消费者这一端配置某种调用超时之后的服务,怎么才能判断是否已经超时呢?
8. 关于超时时间的设定,怎么设置呢?
9. 有几种超时的情况?对应不同的情况你会怎么办?
10. 301 和 302 状态码的区别?
11. HTTP 和 RPC 的关系?
12. 哪里人?平时怎么学习？
13. 你对 B 端和 C 端业务的看法?

## 写在最后

最后决定走新零售场景金融的流程了，淘宝购物车最后还差一个大老板面，钉钉差笔试和交叉，业务中台差笔试和交叉，这些面试都必须进入流程之后才能继续，面不动了，所以后面约的面试都拒了。。希望场景金融后面的面试不会出什么幺蛾子吧。。。。

面试的时候尽量追求实事求是，千万不要想着打面试官的马虎眼，有些东西没做过就是没做过
这次面试面试官帮我回忆了一下我大一大二都在干些什么？
特别是面试官问我大学生活充不充实哪里，真的是感慨特别深
我的大学就是四六级都没考过，补考挂科重修全部经历了一遍，比赛也没参加过，一个奖都没有。。。
交叉面[面经]()后面补。。。。

- [实习]()
- [面经]()
- [阿里巴巴]()
- [Java工程师]()

- 