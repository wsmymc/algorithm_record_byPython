 

## 写在前面

本人双非本科大三，专业是微电子科学与工程，学过一点点 Java，[项目]()是纯 CRUD [项目]()，未接触过 RPC [项目]()，下面是阿里四个部门的[面经]()，让大佬们见笑了

## 2.24 淘宝购物车预面 64 min (过)

1. 自我介绍

2. 学校的学习和实习的时间是怎么分配的?

3. 实习的[项目]()做了什么?遇到的难点?

4. 在实验室做的[项目]()遇到的难点?

5. JPA 和 MyBatis 的区别?讲一下对象字段映射的细节

6. MySQL 各种索引的一些差异

   * ```
     B-Tree:存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优
     劣。例如，MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照
     原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索
     引的行，而InnoDB则根据主键引用被索引的行。
     B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页
     到根的距离相同。图5-1展示了B-Tree索引的抽象表示，大致反映了
     InnoDB索引是如何工作的。MyISAM使用的结构有所不同，但基本思想
     是类似的。
     
     B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据
     适合的查询类型：
     1. 全值匹配
     2. 匹配最左前缀
     3. 匹配列前缀
     4. 匹配范围值
     5. 精确匹配某一列并范围匹配另外一列
     6. 只访问索引的查询
     ```

   * ```
     哈希索引
     哈希索引能以 O(1) 时间进行查找，但是失去了有序性：
     无法用于排序与分组；
     只支持精确查找，无法用于部分查找和范围查找。
     InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。
     ```

   * ```
     全文索引
     MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。
     
     查找条件使用 MATCH AGAINST，而不是普通的 WHERE。
     
     全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。
     
     InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。
     
     #4. 空间数据索引
     ```

   * ```
     空间数据索引（R-Tree）
     MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。
     
     必须使用 GIS 相关的函数来维护数据。
     ```

   * 

7. 什么是聚簇索引?什么是非聚簇索引?

   * 聚簇索引：索引顺序和物理顺序一致，找到索引，就找到相关的所有记录。因为物理顺序只有一个，所以一张表的聚簇索引也只有一个

     ```
     实际存储的循序结构与数据存储的物理机构是一致的，所以通常来说物理顺序结构只有一种，那么一个表的聚簇索引也只能有一个，通常默认都是主键，设置了主键，系统默认就为你加上了聚簇索引，当然有人说我不想拿主键作为聚簇索引，我需要用其他字段作为索引，当然这也是可以的，这就需要你在设置主键之前自己手动的先添加上唯一的聚簇索引，然后再设置主键，这样就木有问题啦。
     ```

   * 非聚蔟索引：

     ```
     非聚集索引并不是在物理上排列数据,即索引中的逻辑顺序并不等同于表中行的物理顺序,索引是指向表中行的位置的指针,这些指针本身是有序的,通过这些指针可以在表中快速定位数据。
     
     由于非聚集索引数据存储时无序的，所以在非聚集索引中指针包含数据行在数据页中的偏移量。即指针由 数据页 + 数据行偏移量 组成。
     ```

8. Innodb 是怎么保证崩溃恢复能力的?(两阶段日志提交)

   * 有binlog和redo log，两阶段日志提交

     ```
     其中，binlog 可以给备库使用，也可以保存起来用于恢复数据库历史数据。它是实现在 server 层的，所有引擎可以共用。redo log 是 InnoDB 特有的日志，用来支持 crash-safe 能力。
     
     一个事务的执行流程，你在最后三步可以看到，redo log 先 prepare 完成，再写 binlog，最后才进入 redo log commit 阶段。
     上述可以概括为两阶段提交
     
     具体：奔溃发生在binlog写完，redo log 还没有commit的情况：
     规则：
     1. 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；
     2. 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：
     a. 如果是，则提交事务；
     b. 否则，回滚事务。
     
     这里，时刻 B 发生 crash 对应的就是 2(a) 的情况，崩溃恢复过程中事务会被提交。
     ```

     

9. Innodb的优缺点?(围绕索引数展开讲)

   * 优点： 支持奔溃回复

   * ```
     索引的优点
     大大减少了服务器需要扫描的数据行数。
     
     帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
     
     将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。
     
     #索引的使用条件
     对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
     
     对于中到大型的表，索引就非常有效；
     
     但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术
     ```

   * 

10. 索引覆盖?回表?唯一索引?非唯一索引?最左原则?

    * ```
      唯一索引
      如果确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候，就应该用关键字UNIQUE把它定义为一个唯一索引，Mysql会在有新纪录插入数据表时，自动检查新纪录的这个字段的值是否已经在某个记录的这个字段里出现过了。如果是，mysql将拒绝插入那条新纪录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复
      ```

    * ```
      回表查询：
      通俗的讲就是，如果索引的列在 select 所需获得的列中（因为在 mysql 中索引是根据索引列的值进行排序的，所以索引节点中存在该列中的部分值）或者根据一次索引查询就能获得记录就不需要回表，如果 select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表。
      ---
      也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。
      ```

    * ```
      覆盖索引：
      只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
      ---
      用自己的话总结，覆盖索引就是不需要回表的查询
      
      翻译过来就是， 要的查询结果就是主键值且查询条件就是非主键索引字段，即在索引树上的查询结果就是我们需要的结果。
      ```

    * ```
      最左匹配原则：
      因为B+树的结构，所以有最左前缀原则/最左匹配原则，意思就是，对于联合索引，只要查询条件与联合索引从左到右部分字段顺序相匹配，该次查询就可以利用联合索引进行加速。
      
      例如现有联合索引（x,y,z）
      
      如果查询条件是WHERE x=1 AND y=2 AND z=3；那么就是对该联合索引的完全匹配。
      
      如果查询条件是WHERE x=1 AND y=2；那么就是利用了该联合索引（符合最左匹配原则）
      
      当然，WHRER x=1;可以以利用该联合索引
      
      如果是WHERE y=2 AND z=3；或者 WHERE z=3；等，就无法利用联合索引（x,y,z）
      ```

    * 

11. explain 里面有哪些字段?

    * ```
      select_type : 查询类型，有简单查询、联合查询、子查询等
      key : 使用的索引
      rows : 扫描的行数
      id： 标识select所属的行，或者顺序
      table: 正在访问那个表
      type: MySQL用户手册上说这一列显示了“关联类型”，但我们认为更准确的说法是访问类型——换言之就是MySQL决定如何查找表中的行
      ```

12. 一个 SQL 查询很慢,从哪些地方进行优化?

    * 1. 切分查询，大查询切分成小查询
      2. 拆分Join。简单地，可以对每一 个表进行一次单表查询，然后将结果在应用程序中进行关联。

13. 自增 ID 和 UUID 的区别?(叶分裂)

    * 自增id有序，所以新添加的也是有序节点
    * UUID首先是无序的，插入时会有随机性，其次UUID一般长，在B+树中，会导致一个节点的索引（指针）太少，树的高度增加.在建立索引和基于索引进行查询时都存在性能问题。

14. 自增 ID 申请完了会发生什么事情?

    * ```
      MySQL自增id用完后，再次申请id，得到的值保持不变。插入数据会报主键冲突异常。
      MySQL InnoDB表未指定主键时，MySQL会指定一个row_id，如果row_id用完了，则会从头开始循环。从这点来说还是建议我们创建表的时候指定主键的，毕竟使用row_id会发生覆盖数据，导致原来的数据丢失，影响数据的可靠性。
      ```

15. 分库解决了什么问题?分表解决了什么问题?

    * ```
      1、随着单库中的数据量越来越大，相应的，查询所需要的时间也越来越多，相当于数据的处理遇到了瓶颈
      2、单库发生意外的时候，需要修复的是所有的数据，而多库中的一个库发生意外的时候，只需要修复一个库（当然，也可以用物理分区的方式处理这种问题）
      ```

16. 你觉得学 Java 需要具备哪些基本条件?哪些地方特别重要?

17. 七层网络模型

    * 物理层、数据链路层、网络、传输、会话、表示、应用

18. 为什么有了七层还有五层的概念?

    * 七层是理论，五层是实际

19. JVM 内存模型(概述)

    * ```
      线程资源：
      
      程序计数器：记录正在执行的虚拟机字节码指令的地址
      ---
      Java虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
      
      该区域可能抛出以下异常：
      
      当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
      栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。
      ---
      本地方法栈： 
      本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。
      
      本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。
      
      
      进程资源：
      堆：
      所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。
      
      现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：
      
      新生代（Young Generation）
      老年代（Old Generation）
      堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。
      
      ---
      方法区：
      用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
      
      和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。
      
      对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。
      方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。
      ```

20. 讲讲双亲委派,为什么?

    * 加载一个类，用低向上请求：（用户自定义类加载器）--》（应用程序类加载器）-->(扩展类加载器)  --> (启动类加载器)

    * 然后自顶向下，寻找各层的目录，找到类进行加载

    * 好处：

      使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。

21. 你觉得双亲委派这个名字有没有什么问题?你讲讲自己的理解

    * 双亲的双字有迷惑性，应该是父级委派

22. 打破双亲委派的例子,举个例子?怎么打破?

    * 重写loadClass方法：

      ```
      默认的loadClass方法是实现了双亲委派机制的逻辑，即会先让父类加载器加载，当无法加载时才由自己加载。这里为了破坏双亲委派机制必须重写loadClass方法，即这里先尝试交由System类加载器加载，加载失败才会由自己加载。它并没有优先交给父类加载器，这就打破了双亲委派机制。
      ```

    * 例子：

      ```
      为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。
      ```

      

23. 你现在用什么 GC 收集器?

24. Eden 区的对象回收策略?

    * 复制算法

    * ```
      年轻代（或称新生代，Young、New）通常用来放新生成的对象（但不绝对，如可以通过-XX:PretenureSizeThreadshold配置将大对象直接分配在老年代）。年轻代的目标就是尽可能快速地收集掉那些生命周期短的对象。
      
      
      年轻代分3个区，1个Eden区，2个Survivor区（from 和 to），但每次只使用Eden和一个Survivor区，另一个Survivor区空着。空Survivor区用来放MinorGC时从Eden和在使用的Survivor区中复制来的活着的对象。
      
      
      针对年轻代的GC为Minor GC或称Young GC，在Eden剩余空间不足以分配新对象时触发
      
      ---
      生成对象（为对象分配内存）的过程如下：
      
      首先看Eden剩余空间是否足够分配该对象，若够则直接在Eden分配；
      否则进行MinorGC：将Eden和在使用的Survivor区中活着的对象复制到另一个Survivor区，并回收Eden和使用着的Survivor区。然后把对象分配到Eden，以后另一个Survivor成为使用的Survivor区；
      若另一个Survivor区不能完全容纳复制过来的对象，则能放下的放入该Survivor，把放不下的放到老年代（即进行分配担保）；
      若老年代剩余空间不够了则进行Full GC，
      若Full GC后仍不够则抛出OOM异常。
      
      具体可以分为：
      
      分配过程（优先在Eden分配）
      分配担保（垃圾回收时Survivor放不下的存活对象移到老年代）
      提前移动的配置（大对象、对象年龄、动态年龄）
      ```

25. CMS 的 STW 情况?

    * 初始标记，标记GC Root，速度快，但是需要停顿
    * 重新标记： 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿

26. CMS 什么情况会触发 Full GC?

    * ```
      1.System.gc()
      在没有开启DisableExplicitGC的情况下，虽然只是建议，但是很多情况下，都会调用Full GC的，比如在原本应进行CMS的时候。System.gc()一般都是用在要释放堆外内存的时候使用。
      
      2.老生代内存不足的时候
      这种情况通常是对象要晋升到老年代中时，发现老年代的内存不足了，所以要引发一次Full GC。对象的晋升分为正常晋升和提前晋升。
      
      3.永生区空间不足时
      有些虚拟机把方法区也放到堆中管理，当加载的类太多时，永生区内存不足需要回收，也会触发Full GC
      
      4.冒险失败之后
       在Minor GC时发现to去的内存不足，则将Eden区和from区的内存全部晋升到老年区，清空新生代。但是如果此时老年区内存不足，则会冒险失败，冒险失败之后，对象仍然留在新生代（此时的Eden区和from区都接近99%），然后出发一次Full GC，这样便于下次如果还有冒险，可以增加冒险成功的几率。
      
      5.HandlePromotionFailure设置为false或者历年平均晋升对象的大小大余老年代剩余连续空间
      在Minor GC之前，虚拟机会检查老年代剩余连续空间是否大余新生代所有对象总大小，如果大余，则说明Minor GC绝对安全；如果小于，则会检查HandlePromotionFailure设置是否担保失败，如果不担保，则在Minor GC之前进行一次Full GC；如果担保，则再检查历年平均晋升对象的大小是否大余老年代剩余连续空间，如果大余，则不冒险，在Minor GC之前进行一次Full GC；如果小于，则冒险，进入情况4。
      
      6.分配大对象时（和2其实是一样的，但是因为特殊，所以单独拿出来说）
      如果直接要分配一个大对象，并且这个大对象的大小超过Eden区的一半，这个对象就会直接分配在老年代，此时如果老年代空间不足，出发一次Full GC，而不出发Minor GC。但是需要注意的是，如果分配的是TLAB而不是真正的大对象，那么不会导致full gc，而是调整TLAB的大小。
      
      7.执行jmap -histo:live或者jmap -dump:live的时候
      这属于强制让虚拟机执行一次full GC。
      ```

      

    

    * ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg)

    * ```
      CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。
      
      分为以下四个流程：
      
      初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
      并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
      重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
      并发清除：不需要停顿。
      在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。
      
      具有以下缺点：
      
      吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
      无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
      标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
      #7. G1 收集器
      ```

    * 

27. 新对象一定会在新生代 new 出来么?

    * 未必，对象过大可能直接在永久代

28. Java8 有什么新的 GC [算法]()?

    * G1

29. 了解 G1 收集器么?

    ![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg)

    ```
    G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。
    
    堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。
    
    
    G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。
    
    
    
    通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。
    
    每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。
    
    
    
    如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：
    
    初始标记
    并发标记
    最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
    筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。
    具备如下特点：
    
    空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
    可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。
    ```

    

30. 考研么?为什么现在的实习想离职了?

31. Golang 和 Java 的区别?

    * ```
      Java和Go都处理完全不同的壁垒。
      Go的指针仅限于数组和对象，它们可以提供指向任何类型的值的指针。
      Go不使用异常来显示运行时和寿命终止之类的事件，而是使用错误来显示此类事件。
      Go基本上被编译为机器代码。
      Java支持省略检查以处理和捕获错误。
      Go提供垃圾回收，但是像Java一样，它不支持完整的GC。
      Go上不允许函数重载，必须具有唯一的方法和函数名称。
      Java中没有原始的无符号数字类型，这就是Java不适合进行底层编程的原因。
      Java中的命名空间不告诉源文件位置。
      Go提供了内置数据类型（例如map和切片），以及一些通用功能（例如复制和追加等）。
      Java仅允许其中包含公共类的源文件。
      Go提供了在OS线程上运行的轻量级线程例程。
      Java 在最佳编程语言列表中排名第18 位，而Go排在第 8 位。
      Go支持复数，因为它对此具有内置支持。
      Java vs Go在多态性方面有不同的看法，Java默认情况下允许多态，而Go则不会。
      Go的API完全由Google处理。
      Java API由开放社区流程控制。
      Java默认使用虚拟方法。
      Java不允许运算符重载，这使其更轻松。
      ```

    * 

32. 反问:有什么需要提高的?

## 2.25 淘宝购物车一面 50 min (过)

1. 上一次面试问了些什么问题?

2. 啥时候过来实习?

3. 挑一两个你实习或者[项目]()当中遇到的难题?讲一讲怎么解决的?

4. [项目]()当中的代码你有没有想过有一些地方可以优化?

5. 哪些情况会出现 OOM?

   * 堆溢出：

     ```\
     Java堆内存主要用来存放运行过程中所以的对象，该区域OOM异常一般会有如下错误信息;
     java.lang.OutofMemoryError:Java heap space
     此类错误一般通过Eclipse Memory Analyzer分析OOM时dump的内存快照就能分析出来，到底是由于程序原因导致的内存泄露，还是由于没有估计好JVM内存的大小而导致的内存溢出。
     
     检查是否内存泄露、或者是-Xmx 调高对空间参数
     ```

   * 栈溢出：

     ```
     另外，由于每个线程占的内存大概为1M，因此线程的创建也需要内存空间。操作系统可用内存-Xmx-MaxPermSize即是栈可用的内存，如果申请创建的线程比较多超过剩余内存的时候，也会抛出如下类似错误：
     
     java.lang.OutofMemoryError: unable to create new native thread
     ```

   * 永久代用满：

     ```
     该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。
     
     原因分析
     永久代存储对象主要包括以下几类：
     
     1、加载/缓存到内存中的 class 定义，包括类的名称，字段，方法和字节码；
     
     2、常量池；
     
     3、对象数组/类型数组所关联的 class；
     
     4、JIT 编译器优化后的 class 信息。
     
     PermGen 的使用量与加载到内存的 class 的数量/大小正相关。
     
     解决方案
     根据 Permgen space 报错的时机，可以采用不同的解决方案，如下所示：
     
     1、程序启动报错，修改 -XX:MaxPermSize 启动参数，调大永久代空间。
     
     2、应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份 class 信息，只需重启 JVM 即可解决。
     
     3、运行时报错，应用程序可能会动态创建大量 class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，可以设置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC这两个参数允许 JVM 卸载 class。
     
     如果上述方法无法解决，可以通过 jmap 命令 dump 内存对象 jmap-dump:format=b,file=dump.hprof<process-id> ，然后利用 Eclipse MAT https://www.eclipse.org/mat 功能逐一分析开销最大的 classloader 和重复 class。
     ```

     

6. 堆中内存分配比例?

   * ```
     ava 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。
     在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。
     这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。
     堆的内存模型大致为：
     
     从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。
     （本人使用的是 JDK1.6，以下涉及的 JVM 默认值均以该版本为准。）
     默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。
     默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。
     JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
     因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间
     ```

7. 新生代 GC 工作流程?

   * Minor GC

     ```
     （1）Eden分配new对象空间不足时，触发Minor GC，此时会对Eden和survivor-from区域内的存活对象，进行复制到survivor-to区域。（此时如果survivor-to空间不足则会直接晋升到老年代）
     （2）Eden和survivor-from区域内非存活对象全部清除
     （3）交换survivor-from 和 survivor-to 区域角色，为下一次Minor GC做准备。
     
     总结：
     （1）Minor GC 总会给自己留后路，随时准备一个空的区域进行存方存活对象。
     （2）并非新生代对象到达年龄时才会被晋升到老年代，在第一步时也是会发生的。
     
     作者：想做安徒生
     链接：https://www.jianshu.com/p/feb8b668deee
     来源：简书
     著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     ```

   * ```
     1. 对象优先在 Eden 分配
     大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。
     
     #2. 大对象直接进入老年代
     大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
     
     经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
     
     -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。
     
     #3. 长期存活的对象进入老年代
     为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
     
     -XX:MaxTenuringThreshold 用来定义年龄的阈值。
     
     #4. 动态对象年龄判定
     虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
     
     #5. 空间分配担保
     在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
     
     如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。
     ```

8. 为什么新生代年龄是 15 次进入老年代?

   * 因为mark down中表示分代年龄的是4个bit，能够表示的最大值是15

9. 大对象进入老年代,这个大对象是有多大?

   * ```
     虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（复习一下：新生代采用复制算法收集内存）。
     所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。
     
     注意　PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。
     ---
     对象优先在新生代分配，但是有的情况对象直接在老年代分配，如下：
     
     1、分配的对象大小大于eden space。适合所有收集器。
     
     2、eden space剩余空间不足分配，且需要分配对象内存大小不小于eden space总空间的一半，直接分配到老年代，不触发Minor GC。适合-XX:+UseParallelGC、-XX:+UseParallelOldGC，即适合Parallel Scavenge。
     
     3、大对象直接进入老年代，使用-XX:PretenureSizeThreshold参数控制，适合-XX:+UseSerialGC、-XX:+UseParNewGC、-XX:+UseConcMarkSweepGC，即适合Serial和ParNew收集器。
     ————————————————
     版权声明：本文为CSDN博主「抱抱-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
     原文链接：https://blog.csdn.net/shi2huang/article/details/80092261
     ```

10. 怎么排查 OOM?

    * ```
      解决方案
      1.查找关键报错信息，如
      java.lang.OutOfMemoryError: Java heap space
      
      2.使用内存映像分析工具（如Eclipsc Memory Analyzer或者Jprofiler）对Dump出来的堆储存快照进行分析，分析清楚是内存泄漏还是内存溢出。
      
      3.如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，修复应用程序中的内存泄漏。
      
      4.如果不存在泄漏，先检查代码是否有死循环，递归等，再考虑用 -Xmx 增加堆大小。
      
      作者：亖狼何需装羴
      链接：https://www.jianshu.com/p/be1c7d048dfc
      来源：简书
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

    * ```
      一般手段是：先通过内存映像工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。
      
      如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。这样就能够找到泄漏的对象是通过怎么样的路径与GC Roots相关联的导致垃圾回收机制无法将其回收。掌握了泄漏对象的类信息和GC Roots引用链的信息，就可以比较准确地定位泄漏代码的位置。
      
      如果不存在泄漏，那么就是内存中的对象确实必须存活着，那么此时就需要通过虚拟机的堆参数（ -Xmx和-Xms）来适当调大参数；从代码上检查是否存在某些对象存活时间过长、持有时间过长的情况，尝试减少运行时内存的消耗。
      ```

    * 工具：

      ```
      1、  jps(Java Virtual Machine Process Status Tool) 
      
      实际中这是最常用的命令，下面要介绍的小工具更多的都是先要使用jps查看出当前有哪些Java进程，获取该Java进程的id后再对该进程进行处理。
      
      2、 jstack
      
          jstack 主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：
          
      3、jmap（Memory Map）
      
           jmap导出堆内存，然后使用jhat来进行分析
      二、MAT 分析Dump
      Dump 是什么
      
      Dump是反应Java堆使用情况的内存镜像，其中主要包括系统信息、虚拟机属性、完-整的线程Dump、所有类和对象的状态等。 一般，在内存不足、GC异常等情况下，我们就会怀疑有内存泄漏。这个时候我们就可以制作堆Dump来查看具体情况。分析原因。
      
      Dump 文件的分析有多种方式
      
            1、命令jhat 分析（麻烦）
      
            2、VisualVM 工具分析 
      
            3、MAT 分析
      
      MAT分析
      
      J2SE中提供了一个简单的命令行工具来对java程序的cpu和heap进行 profiling（剖析面），叫做HPROF
      ```

      

11. 你现在用过哪些中间件?

    * mysql & redis

12. RPC 了解么?

    * https://juejin.cn/post/6855129006019674125

    * ```
      RPC(Remote Procedure Call) 远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。也就是说两台服务器 A，B，一个应用部署在 A 服务器上，想要调用 B 服务器上应用提供的方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据
      
      作者：arjun
      链接：https://juejin.cn/post/6855129006019674125
      来源：掘金
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

    * ```
      在内部系统调用很复杂的前提下，http 调用的效率和安全性就不那么理想了，更重要的是面对众多的服务我们需要的不仅仅是一个通信方式，而是一个内部服务的管理系统，这也就是我们今天说的 RPC 框架，注意 RPC 是一种模式策略和框架，并不是单纯的通信协议。
      ```

    * ```
      RPC 是一种编程模式和概念，并不是非常具体的一种技术，并且和 http 没有明确的冲突，http 可以作为 RPC 传输协议，更重要的是 RPC 是一种内部服务框架，可以涉及服务注册、服务治理、服务发现、熔断机制、负载均衡等。
      ```

    * ```
      基于 TCP 实现的 RPC 调用，能够灵活对协议字段进行定制，减少网络开销提高性能，实现更大的吞吐量和并发数，但要关注底层细节，在进行数据解析时更加复杂一些。
      基于 HTTP 实现的 RPC 可以使用 JSON 和 XML 格式的请求或响应数据，解析工具很成熟，在其上进行二次开发会非常便捷和简单。但是 HTTP 是上层协议，所占用的字节数会比使用 TCP 协议传输所占用的字节数更高。
      
      作者：arjun
      链接：https://juejin.cn/post/6855129006019674125
      来源：掘金
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

13. RPC 解决了现在的哪些问题?

    * 各个分布式服务之间的远程调用

14. 有没有想过把你的[项目]()改造成 RPC?

15. IOC 的初始化流程?

16. AOP是怎么和 IOC 做整合的?

17. 循环依赖怎么解决?

18. [项目]()怎么分层的?

19. JPA 和 MyBatis 做对象映射的区别?原理?

20. 数据库热点查询的数据,怎么做性能优化?

    * 使用缓存

      ```
      如果数据量小，并且不会频繁地增长又清空（这会导致频繁地垃圾回收），那么可以选择本地缓存。具体的话，如果需要一些策略的支持（比如缓存满的逐出策略），可以考虑Ehcache；如不需要，可以考虑HashMap；如需要考虑多线程并发的场景，可以考虑ConcurentHashMap。
      其他情况，可以考虑缓存服务。目前从资源的投入度、可运维性、是否能动态扩容以及配套设施来考虑，我们优先考虑Tair。除非目前Tair还不能支持的场合（比如分布式锁、Hash类型的value），我们考虑用Redis。
      ```

    * ```java
      * 设计关键点
      什么时候更新缓存？如何保障更新的可靠性和实时性？
      更新缓存的策略，需要具体问题具体分析。这里以门店POI的缓存数据为例，来说明一下缓存服务型的缓存更新策略是怎样的？目前约10万个POI数据采用了Tair作为缓存服务，具体更新的策略有两个： * 接收门店变更的消息，准实时更新。 * 给每一个POI缓存数据设置5分钟的过期时间，过期后从DB加载再回设到DB。这个策略是对第一个策略的有力补充，解决了手动变更DB不发消息、接消息更新程序临时出错等问题导致的第一个策略失效的问题。通过这种双保险机制，有效地保证了POI缓存数据的可靠性和实时性。
      
      缓存是否会满，缓存满了怎么办？
      对于一个缓存服务，理论上来说，随着缓存数据的日益增多，在容量有限的情况下，缓存肯定有一天会满的。如何应对？ ① 给缓存服务，选择合适的缓存逐出算法，比如最常见的LRU。 ② 针对当前设置的容量，设置适当的警戒值，比如10G的缓存，当缓存数据达到8G的时候，就开始发出报警，提前排查问题或者扩容。 ③ 给一些没有必要长期保存的key，尽量设置过期时间。
      
      缓存是否允许丢失？丢失了怎么办？
      根据业务场景判断，是否允许丢失。如果不允许，就需要带持久化功能的缓存服务来支持，比如Redis或者Tair。更细节的话，可以根据业务对丢失时间的容忍度，还可以选择更具体的持久化策略，比如Redis的RDB或者AOF。
      
      缓存被“击穿”问题
      对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑另外一个问题：缓存被“击穿”的问题。
      
      概念：缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
      如何解决：业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。类似下面的代码：
      
      public String get(key) {
          String value = redis.get(key);
          if (value == null) { //代表缓存值过期
              //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
              if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
                  value = db.get(key);
                          redis.set(key, value, expire_secs);
                          redis.del(key_mutex);
                  } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
                          sleep(50);
                          get(key);  //重试
                  }
              } else {
                  return value;      
              }
      }
      ```

      

21. Innodb 的索引树数据结构?

    * B+ 树：

      ```
      众所周知，一颗传统的M阶B+树需要满足以下几个要求：
      
      从根节点到叶节点的所有路径都具有相同的长度
      所有数据信息都存储在叶子节点，非叶子节点仅作为叶节点的索引存在
      根节点至少拥有两个子树
      每个树节点最多拥有M个子树
      每个树节点(除了根节点)拥有至少M/2个子树
      
      B+树是为了磁盘及其他存储辅助设备而设计的一种平衡查找树(不是二叉树)，在B+树中，所有记录的节点按大小顺序存放在同一层的叶节点中，各叶子节点用指针进行连接,而B+树索引本质上就是B+树在数据库中的实现，与纯粹的B+树数据结构还是有点区别。
      
      作者：pjmike_pj
      链接：https://juejin.cn/post/6844903760423026702
      来源：掘金
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

    * ```
      B+树是上世纪70年代针对硬盘和单核处理器设计的，为了减少机械硬盘的寻道次数，它采用了多叉树结构，降低了索引结构的深度，IO读写次数减少。
      ```

    * ```
      1. B+树的磁盘读取代价低
      B+-tree的内部节点并没有指向关键字具体信息的指针，换句话说，即分支节点没有存储数据，因此其内部节点相对B 树更小。如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
      2. B+树的查询效率更加稳定
      在B+树中，由于分支节点并不是最终指向文件内容的节点，分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，所有关键字查询路径长度相同，每个数据查询效率相当。而对于B树而言，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，效率也不一样。
      3. B+树便于执行扫库操作
      由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题
      
      作者：pjmike_pj
      链接：https://juejin.cn/post/6844903760423026702
      来源：掘金
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

      

22. 最左原则?

    * 一句话：在使用联合索引时，会自左到右匹配索引，知道索引不被匹配为止

    * ```
       最左前缀匹配原则：在MySQL建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。　　要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建
      ```

    * ```
      为什么要使用联合索引
      减少开销。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！
      覆盖索引。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。
      效率高。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！
      ```

    * 

23. 有没有其他复杂的[项目]()?

24. 排查问题的手段,你目前知道哪些?

25. 讲讲你的优势?

## 3.04 钉钉一面 72 min (过)

1. 自我介绍

2. 介绍一下[项目]()和实习

3. 你对 RPC 的理解?

4. HTTP 和 RPC 的关系?区别?

   * 不是一回事：RPC是更上层的方法，HTTP只是通讯协议，RPC可以使用http，和也可以TCP

5. RPC 的优点?

   * 适应分布式需求
   * 效率更高
   * 更安全

6. 任何一个请求过来都会打到注册中心么?

7. 关于[项目]()和实习的一些问题

8. HDFS 了解么?

   * 分布式文件系统，只知道名字

   * ```
     Hadoop分布式文件系统(HDFS)是指被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统（Distributed File System）。它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。HDFS放宽了一部分POSIX约束，来实现流式读取文件系统数据的目的。HDFS在最开始是作为Apache Nutch搜索引擎项目的基础架构而开发的。HDFS是Apache Hadoop Core项目的一部分。
     HDFS有着高容错性（fault-tolerant）的特点，并且设计用来部署在低廉的（low-cost）硬件上。而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求（requirements）这样可以实现流的形式访问（streaming access）文件系统中的数据。
     ```

   * 

9. Java 的流式处理了解么?

   * ```
     Stream有以下特性及优点：
     
     无存储。Stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。
     
     为函数式编程而生。对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。
     
     惰式执行。Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。
     
     可消费性。Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。
     ————————————————
     版权声明：本文为CSDN博主「Dream_xun」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
     原文链接：https://blog.csdn.net/Dream_xun/article/details/106111195
     ```

   * 

10. SpringMVC 处理请求的一个流程?

    * https://juejin.cn/post/6844903911111802888

    * ```
      具体步骤：
      
      首先用户发送请求到前端控制器（DispatchServlet），前端控制器根据请求URL来决定选择哪一个页面控制器进行处理并把请求委托给它。
      页面控制器接收到请求之后，进行功能处理，首先需要收集和绑定参数到一个对象，这个对象在spring web mcv中叫命令对象，并进行验证，然后将命令对象委托给业务对象处理，处理完毕返回一个ModelAndView（模型数据和逻辑视图）对象。
      前端控制器回收控制权，然后根据返回的逻辑视图名，选着相应的视图进行渲染，并且把模型数据传入以便视图渲染。
      前端控制器再次回收控制权，将响应返回给用户。
      
      作者：Mark_W
      链接：https://juejin.cn/post/6844903911111802888
      来源：掘金
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

11. Servlet 的监听器和拦截器?

    * ```
       Listener是监听器，通过Listener可以监听Web服务器中某一个执行动作，并根据其要求作出相应的响应。通俗的来说就是在Application，Session，Request三个对象创建、消亡或者往其中添加、修改、删除属性时自动执行代码功能的组件。
         
         通过Listener我们可以监听Web应用程序的生命周期，获取HttpSession等创建和销毁的事件；
      ServletContext是一个WebApp运行期的全局唯一实例，可用于设置和共享配置信息。
      ```

    * ```
       Interceptor是拦截器，在JavaWeb中主要是面向切面编程时使用，一般在调用一个方法前亦或是调用一个方法后执行该Interceptor拦截器中的方法。在JavaWeb中应用拦截器，比如说我们想得知一个完整请求的响应时间，我们就可以通过添加拦截器的方式，在请求开始前记录一个开始时间，在请求结束后，记录一个结束时间，用结束时间减去开始时间，即可获取该次请求所消耗的时间。这样以来就可以更加方便我们对于程序的优化处理。
      ————————————————
      版权声明：本文为CSDN博主「张侦毅」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
      原文链接：https://blog.csdn.net/ZZY1078689276/article/details/81239808
      ```

12. 有哪些方法可以拦截一个 HTTP 请求?

    * 过滤器拦截

    * ```
      使用@Bean注入自定义拦截器，依然上面的代码，去掉@Compent注解，创建TimeWebConfig配置类
      ```

    * 拦截器拦截

    * AOP切面拦截

13. 关于接受请求的参数,你有没有一套自己总结的方法?

    * 1. 明确需求
      2. 留有一定的扩展性
      3. 参数名要么可读性强，要和数据库字段一致

14. 在学校还做过哪些[项目]()?

15. 你觉得学 Java,最重要的是什么?

    * spring项目。工作需求上更广，经验要求也多

16. 你对 IOC 的理解?

    * ```
      　　Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：
        
        　　●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。
        
        　　●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。
      ```

    * 

17. AOP 的各种实现有什么差异?

    * http://android9527.com/2018/10/20/2018-10-20-AOP%E6%8A%80%E6%9C%AF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/

    * ```
      动态代理
      优点：
      
      Java API 提供的，兼容性好，无需依赖其他库，
      动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。
      动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java 反射机制可以生成任意类型的动态代理类。
      缺点：
      
      只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。
      没有代码注入步骤，必须手动实例化并应用，
      功能有限，只能在方法前后执行一些代码
      APT
      优点：
      
      任何你不想做的繁杂的工作，它可以帮你减少样板代码
      生成代码位置的可控性（可以在任意包位置生成代码），与原有代码的关联性更为紧密方便
      缺点：
      
      只有被注解标记了的类或方法等，才可以被处理或收集信息。
      APT可以自动生成代码，但在运行时却需要主动调用
      Javassist ：
      
      功能强大，使用方便，
      由于Javassist可以直接操作修改编译后的字节码，直接绕过了java编译器，所以可以做很多突破限制的事情，例如，跨dex引用，解决热修复中CLASS_ISPREVERIFIED的问题。
      运行时生成，减少不必要的生成开销；通过将切面逻辑写入字节码，减少了生成子类的开销，不会产生过多子类。运行时加入切面逻辑，产生性能开销。
      Aspectj：
      
      AspectJ除了hook之外，AspectJ还可以为目标类添加变量，接口。另外，AspectJ也有抽象，继承等各种更高级的玩法。它能够在编译期间直接修改源代码生成class。
      AspectJ语法比较多，但是掌握几个简单常用的，就能实现绝大多数切片，完全兼容Java（纯Java语言开发，然后使用AspectJ注解，简称@AspectJ。）
      ```

18. 为什么会有多种代理的方式?

    * ```
      静态代理
      在上文代理模式代码演进中就使用了静态代理模式。所谓静态代理中的“静”字，无非就是代理类的创建时机不同罢了。静态代理需要为每个被代理的对象手动创建一个代理类；而动态代理则时在运行时通过某种机制来动态生成，不需要手动创建代理类。
      动态代理 - jdk
      jdk动态代理模式是利用java中的反射技术，在运行时动态创建代理类。接下来我们仍借助上文中的订单服务的案例，使用jdk动态代理实现。
      基于动态jdk涉及到两个核心的类Proxy类和一个 InvocationHandler接口。
      
      作者：Java填坑笔记
      链接：https://juejin.cn/post/6844904003839459341
      来源：掘金
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

      * cglib动态代理

      * ```
        于cglib我想大多数人应该都很陌生，或者是在学习Spring中AOP（面向切面编程）时听说了它使用jdk和cglib两种方式实现了动态代理。接下来笔者将针对cglib进行简要介绍。
        cglib动态代理和jdk动态代理类似，也是采用操作字节码机制，在运行时生成代理类。cglib 动态代理采取的是创建目标类的子类的方式，因为是子类化，我们可以达到近似使用被调用者本身的效果。
        
        
        ---
        cglib动态代理实现步骤和jdk及其相似，可以分为以下几个步骤：
        
        创建一个实现MethodInterceptor接口的类
        在类中定义一个被代理对象的成员属性，为了扩展方便可以直接使用Object类，也可以根据需求定义相应的接口
        在invoke方法中实现对委托对象的调用，根据需求对方法进行增强
        使用Enhancer创建生成代理对象，并提供要给获取代理对象的方法
        
        作者：Java填坑笔记
        链接：https://juejin.cn/post/6844904003839459341
        来源：掘金
        著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
        ```

      * 

19. HTTPS 的秘钥交换过程?

20. 有中间人劫持则么办?

    * 信任了不该信任的证书，就会有风险
    * 检查是否有未经新人的证书
    * 最好的方法，卸掉所有证书，重新装可信的

21. 双亲委派的理解?

22. 为什么有双亲委派?一定要遵循双亲委派么?

23. 怎么打破双亲委派?

    * 重写类加载器，--》 重写findClass()

24. 有一个线程要等待其他线程执行完再执行?

    * https://www.cnblogs.com/pony1223/p/9349239.html CountDownLatch

25. 有一个线程要等待其他线程都就绪再执行?

    * https://blog.csdn.net/uncle_king/article/details/79195185 CoutDownLatch or  CyclicBarrier
    * https://blog.csdn.net/weixin_44337261/article/details/98477048?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control

26. 顺序打印 ABC?

    * https://blog.csdn.net/WaterTheGreat/article/details/79072950

27. Innodb 索引的数据结构?为什么用 B+树?

    * 平衡
    * 树高少
    * 既可以从树根查询，也可以顺序查询，范围查询

28. 100 瓶药一瓶毒药.懂得都懂.

29. [海量数据]()取前 5.

## 3.04 业务中台一面 52 min (过)

1. 自我介绍

2. 有没有面其他的部门?

3. 介绍一下自己的实习[项目]()?

4. 关于[项目]()的一些问题

5. 你觉得实习做的事情还有没有什么可以优化的?

6. 为什么 TX 用 Golang?(我怎么知道?)

7. DNS 解析流程?

   * ```
     1. 检查浏览器缓存中是否缓存过该域名对应的IP地址
     2. 果在浏览器缓存中没有找到IP，那么将继续查找本机系统是否缓存过IP
     3. 向本地域名解析服务系统发起域名解析的请求
     4. 通过递归或者迭代的方式，根 -- 》 顶级 --》确定的域名
     5. 服务器接收本地域名服务器发起的请求，并根据需要解析的域名，找到该域名对应的域名服务器，通常情况下，这个服务器就是你注册的域名服务器，那么你注册的域名的服务商的服务器将承担起域名解析的任务。
     6. 服务器查找域名对应的地址，将地址连同值返回给本地域名服务器。
     7. 本地域名服务器缓存解析后的结果，缓存时间由时间来控制。
     ```

8. 怎样解析一个域名?解析一个域名需要哪些信息?

9. 为什么用 Nginx?

10. 你觉得 Nginx 在你的[项目]()中最大的作用是什么?

11. HTTPS 的秘钥交换过程?

12. 你觉得使用了 HTTPS 之后还会出现问题么?出现问题了怎么办?

    * csrf
    * xss

13. 外挂的 Tomcat 和 SpringBoot 内嵌的 Tomcat 有什么区别?

14. Tomcat 的设计模式了解么?

15. SpringBoot 怎么调起Tomcat?

16. 你对 IOC 的理解?

17. 实际开发当中你哪些地方使用了 Bean 的前置后置处理器?

18. AOP 是怎么和 IOC 进行整合的?

19. Spring 怎么把 Java 对象初始化成 SpringBean 的?

20. HashMap 八股文讲讲?

    * http://www.cyc2018.xyz/Java/Java%20%E5%AE%B9%E5%99%A8.html#concurrenthashmap

21. 哪些情况下会产生 Full GC?

    * ```
      1. System.gc()
      2. 老年代空间不足
      3. 空间分配担保失败
      4. JDK1.7 及以前的用就嗲空间不足：在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
      当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。
      为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。
      
      5. Concurrent Mode Failure
      执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。
      
      
      ```

    * 

22. 方法区的大小怎么设置?

    * ```
      元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定,替代上述原有的两个参数
      分别对应初始和最大
      ```

    * 堆

      ```
      首先要知道：
      
      （1）-Xms<size>：用于设置jvm堆内存的初始大小
      
      （2）-Xmx<size>：用于设置jvm堆内存的最大可用内存
      ```

      

23. 栈大小怎么设置?

    * ```
      分配参数：-Xss
      特点：
      (1)局部变量、参数都分配在栈上。
      (2)栈的内存通常只有几百k，但是它决定了函数调用的深度；如果程序使用了很深的递归函数，而栈内存又非常小，此时很有可能发生栈溢出(java.lang.StackOverflowError)的情况。
      (3)每一个线程都有独立的栈空间。如果想尽量多跑一些线程的话，就尽量将栈内存缩小，而不是增大。
      ```

24. 你遇到过堆栈溢出的情况么?怎么解决的?

    * StackOverFlow:

      ```
      ava 里的 StackOverflowError。抛出这个错误表明应用程序因为深递归导致栈被耗尽了。每当java程序启动一个新的线程时，java虚拟机会为他分配一个栈，java栈以帧为单位保持线程运行状态；当线程调用一个方法是，jvm压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个栈帧就存在。 如果方法的嵌套调用层次太多(如递归调用),随着java栈中的帧的增多，最终导致这个线程的栈中的所有栈帧的大小的总和大于-Xss设置的值，而产生生StackOverflowError溢出异常。
      
      作者：SunnyMore
      链接：https://www.jianshu.com/p/faad22e1faf0
      来源：简书
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

    * ```
      如果你确认递归实现是正确的，为了允许大量的调用，你可以增加栈的大小。依赖于安装的 Java 虚拟机，默认的线程栈大小可能是 512KB 或者 1MB。你可以使用 -Xss 标识来增加线程栈的大小。这个标识即可以通过项目的配置也可以通过命令行来指定。-Xss 参数的格式：
      
      作者：SunnyMore
      链接：https://www.jianshu.com/p/faad22e1faf0
      来源：简书
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

    * 

25. MySQl 主从集群怎么搞?

    * 主从之间传递的binlog

    * ```
      1.数据库复制 replication 的实现原理
      
      (1).主服务器凡运行语句，都产生一个二进制日志 binlog
      
      (2).从服务器不断读取主服务器的binlog
      
      (3).从主服务读取到的binlog，转换为自身可执行的relaylog
      
      (4).执行relaylog
      
      2.实现步骤：
      
      (1).首先确保主服务器打开二进制日志功能，主服务器一旦有数据变化，立即产生二进制日志
      
      (2).从服务器也需要开启二进制日志和relay日志功能，这样可以从主服务器读取binlog，并产生relaylog
      
      (3).在主服务器建立一个从服务器的账号，并授予数得上权限
      
      (4).指定从服务对应的主服务器，开启从服务器
      
      作者：杍劼
      链接：https://www.jianshu.com/p/2ce0bc1acc3f
      来源：简书
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

    * 

26. Binlog 有几种?区别是什么?

    * ```
      有三种格式，statement，row和mixed。
      
      statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
      row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
      mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
      ————————————————
      版权声明：本文为CSDN博主「猫巳」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
      原文链接：https://blog.csdn.net/qq_31635851/article/details/109599527
      ```

    * 

## 3.05 业务中台二面 75 min (过)

1. 面试官上来花了 10 分钟介绍了他们部门

2. 关于 Github 上面的[项目]()的问题(这个代码是大二上期写的)

3. [项目]()当中的数据库设计,你是怎么做的?

4. [项目]()怎么分层的?

5. 流量打到 SpringMVC 上面之后的处理流程?

6. 微信小程序登录的流程?

7. JS SDK 登录和后端请求微信服务器登录的区别?

8. 你觉得微信登录获得的 raw 信息可以被黑客劫持么?

9. 你使用过分表么?分库分表分别解决了什么问题?

10. 分表的时候,怎么设计主键?

    * 一般用自增id
    * 唯一，较短

11. 自己的[项目]()当中,用到自定义索引的情况?

12. 最左原则?联合索引?

13. 为什么会有最左匹配原则?(根据 B+树[排序]()规则去回答)

    * ```
      最左匹配原则的成因：
      
      1.Mysql创建联合索引是首先会对最左边，也就是第一个索引字段进行排序
      
      2.在第一个排序的基础上，再对第二个索引字段进行排序，其实就像是实现了Order by字段1，再Order by 字段2这样一种排序规则
      
      3.所以第一个字段是绝对有序的，而第二个字段就是无序的了
      
      4.因此通常情况下，直接使用第二个字段进行条件判断是用不到索引的。这就是为什么mysql要强调最左匹配原则的成因。
      ————————————————
      版权声明：本文为CSDN博主「IMUHERO」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
      原文链接：https://blog.csdn.net/qq_37768971/article/details/100026327
      ```

    * ```
      我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。
      ---
      可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。
      
      同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a>1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。
      ```

14. 为什么使用 B+树?回表?怎么减少回表?

    * 使用覆盖索引
    * 为经常查询的值建立索引

15. 数据库的乐观锁和悲观锁?

    * ```
      观锁
      悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。
      
      悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
      
      Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。
      
      乐观锁
      乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。
      
      乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
      
      乐观锁一般来说有以下2种方式：
      
      使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。
      使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。
      
      作者：FX_SKY
      链接：https://www.jianshu.com/p/f5ff017db62a
      来源：简书
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
      ```

    * 

16. 读锁和写锁的区别?

    * ```
      排它锁也称独占锁、写锁或X锁，若sessionA获得某数据表的排他锁权限，那么sessionA只能对该表进行读取或修改，其他session既不能读取也不能修改该表，更不能对该表加任何类型的锁，直到sessionA释放排它锁权限。加锁方式：lock tables tablename write；操作如下：
      ————————————————
      共享锁也称读锁或S锁，若sessionA获得某数据表的共享锁权限，那么任何session（包括sessionA）只能对该表进行读取，不能修改该表，其他session可以对该数据表继续加S锁但不能加X锁，直到sessionA释放共享锁权限。加锁方式：set tables tablename read；操作如下：
      ————————————————
      版权声明：本文为CSDN博主「Jeaforea」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
      原文链接：https://blog.csdn.net/Jeaforea/article/details/52096058
      ```

    * 

17. 假设现在有一个需求,需要在一个 for 循环里面连续 100 次去更新一个行记录,这个过程中会出现阻塞的情况?怎么使用编码的方式来规避这种情况?(手动继承 AQS)

18. 怎么关闭长事务?

    * https://cloud.tencent.com/developer/article/1511089

19. 为什么想来阿里?

20. 微服务实例是怎么暂停的?了解么?

21. 关于实习和[项目]()的一些问题

22. 线程池 7 个参数的含义?

    * https://blog.csdn.net/u022812849/article/details/109057323

    * ```
      创建一个线程池时需要输入几个参数，如下：
      
      corePoolSize（最大核心线程的数量）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使此时其他核心线程空闲也会创建新的核心线程，直到核心线程的数量等于最大核心线程的数量corePoolSize。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。
      maximumPoolSize（最大线程的数量）：线程池允许创建的最大线程数。如果阻塞队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界队列这个参数就没有意义。
      keepAliveTime（非核心线程的空闲时间）：非核心线程等待keepAliveTime时间后还没有获取到任务就会自动销毁。
      unit：空闲时间的单位。
      workQueue（任务队列）：用于保存等待执行的任务的阻塞队列。
      ThreadFactory：用于创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，后期方便定位问题。
      RejectedExecutionHandler（拒绝策略）：当线程池中的线程达到maximumPoolSize，说明线程池处于饱和状态，此时仍然有任务提交过来，那么必须采取一种策略处理提交的新任务。
      ————————————————
      版权声明：本文为CSDN博主「morris131」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
      原文链接：https://blog.csdn.net/u022812849/article/details/109057323
      ```

    * 

23. 线程池提交任务的流程?

    * ```
      流程解释为:
      
      当线程池新加入一个线程时，首先判断当前线程数，是否小于coreSize，如果小于，则执行步骤2，否则执行3
      创建新线程添加到线程池中，跳转结束
      判断当前线程池等待队列是否已满，若已满，则跳转至步骤5
      加入等待队列，等待线程池空闲，跳转结束
      判断当前线程数是否已达到maximumPoolSize，若未达到，则跳转至步骤7
      执行线程池拒绝策略，跳转结束
      创建一个新线程，执行任务
      跳转结束
      ————————————————
      版权声明：本文为CSDN博主「爱上编程的小白」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
      原文链接：https://blog.csdn.net/w13485673086/article/details/87920295
      ```

    * ![img](https://img-blog.csdnimg.cn/20190225170210368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMzQ4NTY3MzA4Ng==,size_16,color_FFFFFF,t_70)

24. 对分布式的了解有多少?

## 3.05 钉钉二面 50 min (过)

这轮面试忘了录音了,有些问题不记得了.

1. 关于[项目]()和实习的一些问题.
2. 一个分布式部署的[项目]()?至少需要哪些模块?
3. 任何一个流量打过来都会打到注册中心么?
4. 一个注册中心,至少需要具备哪些条件?
5. 有一大批流量总是被打到一个实例上面,这个实例的兄弟实例分到的流量很少,怎么办?
6. 有一个实例挂了怎么办?
7. 注册中心集群的时候,其中一个注册中心挂了怎么办?
8. 平时通过哪些渠道学习?
9. 看过哪些博客?
10. 你觉得[美团]()的博客上面有哪几篇对你帮助特别大?
11. 然后具体谈了谈这一篇博客
12. 你看视频一般在哪儿看?看那些类型的视频?
13. 能给我推荐一个关于技术的公众号么?
14. 你有看过阿里的一些技术博客么?你觉得他们写的博客对你有没有帮助?

剩下的八股文问题不记得了.....

## 3.05 淘宝购物车二面 60 min (过)

这一轮面试也忘了录音了....

1. 自我介绍

2. 关于[项目]()和实习的一些问题

3. HashMap put 里面已经有100000 个数据了,往里面 put 第 100001 个数据会不会扩容?

4. 你觉得采用[链表]()加[红黑树]()的组合方式之后解决了什么问题?

   * https://www.cs.usfca.edu/~galles/visualization/BFS.html
   * 冲突后的性能问题

5. 那么多数据结构,为什么偏偏使用[红黑树]()?

   * 一种平衡

6. [红黑树]()的平衡怎么做?

   * 红色节点的个数差距不大于1
   * 颜色翻转和旋转

7. [链表]()转化成[红黑树]()的阈值怎么算出来的?

   * ```
     当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是拍拍屁股决定的，而是根据概率统计决定的。由此可见，发展30年的Java每一项改动和优化都是非常严谨和科学的
     ————————————————
     版权声明：本文为CSDN博主「做一个坏人」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
     原文链接：https://blog.csdn.net/sinat_41832255/article/details/88884586
     ```

   * 

8. 为什么[红黑树]()缩回[链表]()的阈值和进化的阈值不一样?

   * hash的目的就是让碰撞极小，所以如果出现恰好的8边缘变动，两种形态变换浪费资源

9. 现在用编码的方式进行代码同步,有哪些方法?

   * synchronized
   * Reentrentlock
   * CountDownLatch
   *  CyclicBarrier

10. 公平锁和非公平锁的实现(AQS 八股文)

11. volatile 的特性?

    * 指令加屏障，禁止重拍
    * 增强可见性，各个线程看到的值是相同的

12. 一个 volatile 变量,一个线程写,多个线程读会不会出现线程不安全的问题?

13. IOC 的初始化流程?

14. Java 的类加载过程?

    * ```
      类加载过程
      包含了加载、验证、准备、解析和初始化这 5 个阶段。
      
      #1. 加载
      加载是类加载的一个阶段，注意不要混淆。
      
      加载过程完成以下三件事：
      
      通过类的完全限定名称获取定义该类的二进制字节流。
      将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
      在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。
      其中二进制字节流可以从以下方式中获取：
      
      从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
      从网络中获取，最典型的应用是 Applet。
      运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
      由其他文件生成，例如由 JSP 文件生成对应的 Class 类。
      #2. 验证
      确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
      3. 准备
      类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。
      
      实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。
      
      初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123
      4. 解析
      将常量池的符号引用替换为直接引用的过程。
      
      其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。
      
      #5. 初始化
      初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit\>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。
      ```

    * 

15. 为什么会有 TIMEWAIT这个状态?![tcp-closing-connection](https://img.draveness.me/2020-03-10-15838517142219-tcp-closing-connection.png)

    * 

    * ```
      当客户端没有待发送的数据时，它会向服务端发送 FIN 消息，发送消息后会进入 FIN_WAIT_1 状态；
      服务端接收到客户端的 FIN 消息后，会进入 CLOSE_WAIT 状态并向客户端发送 ACK 消息，客户端接收到 ACK 消息时会进入 FIN_WAIT_2 状态；
      当服务端没有待发送的数据时，服务端会向客户端发送 FIN 消息；
      客户端接收到 FIN 消息后，会进入 TIME_WAIT 状态并向服务端发送 ACK 消息，服务端收到后会进入 CLOSED 状态；
      客户端等待两个最大数据段生命周期（Maximum segment lifetime，MSL）2的时间后也会进入 CLOSED 状态；
      ```

    * ```
      从上述过程中，我们会发现 TIME_WAIT 仅在主动断开连接的一方出现，被动断开连接的一方会直接进入 CLOSED 状态，进入 TIME_WAIT 的客户端需要等待 2 MSL 才可以真正关闭连接。TCP 协议需要 TIME_WAIT 状态的原因和客户端需要等待两个 MSL 不能直接进入 CLOSED 状态的原因是一样的3：
      
      防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；
      保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 FIN 对应的 ACK 消息；
      ```

    * 

16. 拥塞控制?流量控制?

17. 10000 亿条淘宝订单,每条订单当中包含了一个交易流水,流水里面有商品的 ID,有购买数量,同一个商品在这个订单会出现多次,现在要统计销量最好的 10 件商品.

能记起来的就这些.....

## 3.06 新零售场景金融一面 70 min (过)

1. 为什么不找硬件相关的实习来做软件?

2. 能给我介绍一下微电子科学与工程这个专业是干什么的么?

3. 你是怎么学习软件开发的这些东西?

4. 关于实习和[项目]()的问题

5. 讲讲面向对象的一些特性?

6. Java 7 大原则?

   * ```
     单一职责原则
     里氏替换原则
     依赖倒置原则
     接口隔离原则
     迪米特法则-最少知道原则
     开闭原则
     组合/聚合复用原则
     ```

7. 面向过程和面向对象的区别?

8. 对象和类的关系?

9. Java 容器八股文

10. HashMap 八股文

11. 进程和线程的区别?

12. Java 创建线程的方式?

13. 线程池参数和任务提交到执行的过程?

14. 对于线程池参数的设定,你有没有自己的一套方案?

15. 代码的同步怎么做?

16. Java 的类加载过程?什么时候回触发到 Java 类的加载?什么时候回触发类的卸载?

17. 双亲委派?打破双亲委派?

18. 重载和重写在 JVM 层面是怎么鉴别的?

19. JVM当中的方法内联?

20. MySQL中的事务是怎么实现的?

21. 隔离级别的区别?都是怎么实现的?

22. 事务数组是什么?高水位指的是哪些?低水位指的是哪些?

23. Innodb 索引数据结构?阿巴阿巴

24. SQL 语句执行流程?分析器优化器执行器都是什么?

25. 回表?索引下推?

26. IOC 的初始化流程?

27. 为什么会有 SpringBoot 的出现?

28. 讲讲自动装配?

29. 你更倾向于 MyBatis 还是 JPA?

30. 这两个 ORM 的实现和区别?

31. 问[项目]()....

32. 问实习...

33. 你的大学生活,时间一般是怎样安排的?

34. 你觉得你自己的大学生活充实么?

35. 一般采用哪些方式学习?

36. B 端业务和 C 端业务你更倾向于哪种?

## 3.06 新零售场景金融二面 110 min (过)

1. 自我介绍
2. 本专业的成绩怎么样?
3. 挂过科么?为什么会挂科?能不能总结一下这一次挂科?
4. JVM内存模型概念?
5. 你对方法区/元空间的理解?
6. 堆中内存的分配?
7. 永久带会涉及到 GC 回收么?
8. 程序运行的时候,怎么监控内存使用情况?
9. 程序运行的时候,怎么看堆栈信息?
10. Java 类加载的过程?
11. 魔数是什么?
12. 为什么叫双亲委派?你有没有觉得这个名字怪怪的?
13. 在一个类中调用了另一个类的私有方法能不能通过编译?
14. ClassNotFoundException出现在哪些地方?
    * 类加载过程中
15. 假如说现在有一个 可执行的A.jar和 B.jar,他们都互相引用了对方,现在 B.jar 里面的某些类已经不在了,A还能启动么?
16. ldc,iconst,getstatic,ACC_FLAG 这几个指令都是什么意思?
17. IOC 的特性?你对 IOC 的理解?
18. 我们自己也可以实现 IOC 和 AOP,甚至是前置后置处理器,为什么还要用 Spring 提供的?
19. 怎样才能知道 Spring 的 IOC 容器已经完全初始化了?
20. 事件订阅的接口名字是什么?
21. 为什么我会问这个问题?为什么我们需要知道 Spring IOC 容器的初始化进度?
22. Spring 的后置处理器接口名字是什么?
23. AOP 和 IOC 的整合流程?
24. AOP 是怎么做动态代理的?
25. CGLIB 是怎么操作字节码的?
26. ASM 操作字节码的原理?
27. XML 的两种解析策略?两种有什么差异?
28. 线程池参数?
29. 任务提交到线程池之后会遇到哪些情况?
30. 用银行取钱的例子给我讲讲线程池?
31. sync 对应的字节码是什么?
32. sync 锁静态方法和非静态方法锁的分别是什么对象?
33. 为什么锁的对象不一样?
34. 为什么使用 Maven?
35. 一个 a.jar 引用了 c,版本是 1.0.0,b.jar 引用的 c 版本是 2.0.0,一个[项目]()当中同时依赖了a 和 b,这时候依赖的 c 版本是哪一个?为什么?
36. Maven 仲裁策略有几步?
37. 数据库的事务特性?
38. 隔离级别的差异?为什么会有这种差异?
39. 讲讲可重复读和读提交隔离级别和实现机制?
40. 什么是"当前读"?
41. 为什么[项目]()当中要使用缓存?
    * 热点数据，mysql太慢
42. 为什么 Redis 这么快?
    * 单线程
    * 内存读取
    * 无锁
    * 数据结构有优化
43. Redis的持久化机制?
44. 在生成 RDB 的过程当中,还能继续进行写入么?
45. 为什么 AOF 是数据先落盘再写日志?而数据库是先写日志再落盘?
46. 哨兵的选主策略?一个哨兵是怎么知道其他哨兵的存在的?
47. HashMap 八股文
48. [红黑树]()的特点?
49. 三次握手和四次挥手的过程?
50. TIMEWAIT 为什么要等待 2MSL?
51. 301 和 302 状态码的区别?
52. 磁盘调度[算法]()?
53. 操作系统死锁?
54. 进程和线程的区别?
55. 哪一种 IPC 最快?
    * 直接内存
56. 线程的几种状态?
57. 进程调度策略?
58. 三点十五分时针和分针的夹角?

## 3.07 业务中台三面 35min (过)

1. 自我介绍

2. 问[项目](),问实习

3. 你在[项目]()当中担任的角色?

4. 你觉得 TX 的氛围怎么样?

5. 你一般几点走?

6. 那边加班严重么?

7. RPC 调用过程中,现在要在消费者这一端配置某种调用超时之后的服务,怎么才能判断是否已经超时呢?

8. 关于超时时间的设定,怎么设置呢?

9. 有几种超时的情况?对应不同的情况你会怎么办?

10. 301 和 302 状态码的区别?

    * ```
        301 redirect: 301 代表永久性转移(Permanently Moved)
        
        302 redirect: 302 代表暂时性转移(Temporarily Moved )
      ```

    * 

11. HTTP 和 RPC 的关系?

12. 哪里人?平时怎么学习？

13. 你对 B 端和 C 端业务的看法?

## 写在最后

最后决定走新零售场景金融的流程了，淘宝购物车最后还差一个大老板面，钉钉差笔试和交叉，业务中台差笔试和交叉，这些面试都必须进入流程之后才能继续，面不动了，所以后面约的面试都拒了。。希望场景金融后面的面试不会出什么幺蛾子吧。。。。

面试的时候尽量追求实事求是，千万不要想着打面试官的马虎眼，有些东西没做过就是没做过
这次面试面试官帮我回忆了一下我大一大二都在干些什么？
特别是面试官问我大学生活充不充实哪里，真的是感慨特别深
我的大学就是四六级都没考过，补考挂科重修全部经历了一遍，比赛也没参加过，一个奖都没有。。。
交叉面[面经]()后面补。。。。

- [实习]()
- [面经]()
- [阿里巴巴]()
- [Java工程师]()

- 