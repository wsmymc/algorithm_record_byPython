# Java八股

## HashMap

https://www.jianshu.com/p/9b12a52cfceb

* 结构：

  1.7 ： 数组加链表

  1.8： 数组 + 链表/红黑树：

  * 为何变化长度是8：

    * 链表时间复杂度是O(n/2), 红黑树是O(longn), n ==8 时， log8 < (8/2)。此时更快

  * 为何缩回去是6：

    * 频繁的从链表转到红黑树，再从红黑树转到链表，开销会很大，特别是频繁的从链表转到红黑树时，需要旋转

  * 为何是红黑树而不是AVL树？

    * ```
      因为 AVL 树比红黑树保持着更加严格的平衡， AVL 树中从根到最深叶的路径最多为 1.44log（n + 2） ，红黑树中则最多为 2log（ n + 1） ，所以 AVL 树查找效果会比较快，如果是查找密集型任务使用 AVL 树比较好，相反插入密集型任务，使用红黑树效果就比较 nice
      
      AVL 树在每个节点上都会存储平衡因子
      
      AVL 树的旋转比红黑树的旋转更加难以平衡和调试，如果两个都给 O（lgn） 查找， AVL 树可能需要 O（log n） 旋转，而红黑树最多需要两次旋转使其达到平衡
      
      
      ```

* 为何线程不安全？

  * 扩容时发生死循环

    * ```
      扩容时导致的死循环，这个问题只会在 1.7 版本及以前出现，因为在 1.7 版本及以前，扩容时的实现，采用的是头插法，这样就会导致循环链表的问题
      
      什么时候会触发扩容呢？如果存储的数据，大于 当前的 HashMap 长度（ Capacity ） * 负载因子（ LoadFactor ，默认为 0.75） 时，就会发生扩容。比如当前容量是 16 ， 16 * 0.75 = 12 ，当存储第 13 个元素时，经过判断发现需要进行扩容，那么这个时候 HashMap 就会先进行扩容的操作
      
      扩容也不是简简单单的将原来的容量扩大就完事儿了，扩容时，首先创建一个新的 Entry 空数组，长度是原数组的 2 倍，扩容完毕之后还会再进行 ReHash ，也就是将原 Entry 数组里面的数据，重新 hash 到新数组里面去
      
      ```

    * 1.8 采用尾插法解决该问题

  * 数据覆盖问题

    ```
    假设现在线程 A 和线程 B 同时进行 put 操作，特别巧的是这两条不同的数据 hash 值一样，并且这个位置数据为 null ，那么是不是应该让线程 A 和 B 都执行 put 操作。假设线程 A 在要进行插入数据时被挂起，然后线程 B 正常执行将数据插入了，然后线程 A 获得了 CPU 时间片，也开始进行数据插入操作，那么就将线程 B 的数据给覆盖掉了
    
    因为 HashMap 对 put 操作没有进行加锁的操作，那么就不能保证下一个线程 get 到的值，就一定是没有被修改过的值，所以 HashMap 是不安全的
    
    作者：热衷技术的Java程序员
    链接：https://www.jianshu.com/p/9b12a52cfceb
    来源：简书
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    ```

  

  * 因此推荐ConcurrentHashMap

  * ```
    在 1.7 版本， ConcurrentHashMap 采用的是分段锁（ ReentrantLock + Segment + HashEntry ）实现，也就是将一个 HashMap 分成多个段，然后每一段都分配一把锁，这样去支持多线程环境下的访问。但是这样锁的粒度太大了，因为你锁的直接就是一段嘛
    
    所以 1.8 版本又做了优化，使用 CAS + synchronized + Node + 红黑树 来实现，这样就将锁的粒度降低了，同时使用 synchronized 来加锁，相比于 ReentrantLock 来说，会节省比较多的内存空间
    
    ```

    

  

## ConcurrentHashMap

https://www.jianshu.com/p/460bf90b9137

* 基本原理：

  ```
  内部持有一个Node<K,V>[]，用来存放key,value。
  1.1 这个数组的默认长度是16，并且只会在第一次put的时候才会初始化（lazy init）。
  put 的时候要通过运算得到应存放的数组下标，然后根据不同的情况决定初始化数组、插入链表、插入红黑树或者协助扩容。
  2.1 先进行hash扰动。
  2.2 数组如果还未进行初始化，则先进行初始化。初始化默认大小为16，如果指定了初始化大小，则会计算一个>=指定值，且为2的N次幂的数字，且最接近当前参数的数字作为初始长度。
  2.3 当前位置==null，则直接通过CAS插入数据。
  2.4 如果当前数组正在进行扩容，则协助扩容。
  2.6 当前位置!=null。如果当前节点是红黑树，则直接插入树中。否则作为链表插入链表插入或者更新。
  2.7 插入成功后，如果是链表，则检查是否需要转成红黑树。转换条件是链表节点数>=8，且数组长度>64。
  2.8 最后更新size的值，并且检查是否需要扩容。
  get的时候同样通过运算得到应存放的数组下标，然后进行遍历。
  3.1 先进行hash扰动，使用hash&(n-1)得到数组索引。
  3.2 取索引对应的数据进行遍历。可能是链表、红黑树，也可能是FWD节点。
  size++的时候，先尝试用更新volatile baseCount，更新失败再尝试定位到具体的CounteCell，用CAS或者直接更新其volatile value。
  
  ```

  