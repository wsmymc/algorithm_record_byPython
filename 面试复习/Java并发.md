## Java并发

## 2. 并发机制底层原理

### 2.1 volatile

volatile 命令作用 ；

1）将当前处理器缓存行的数据写回到系统内存。

2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

### 2.2 syncvhronized

在JDK 1.6 以后，进行了各种优化，synchronized 由重变轻

先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。

·对于普通同步方法，锁是当前实例对象。

·对于静态同步方法，锁是当前类的Class对象。

·对于同步方法块，锁是Synchonized括号里配置的对象。

```
从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。

monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。
```

方法同步和代码块同步  ————》 基于进入和退出Monitor对象——》具体可以使用 moniterenter 和 monitorexit ————》 在编译后插入到开始和结束的位置，根据指令获取或释放moniter的所有权

#### 2.2.1 java对象头

* 如果是非数组类型，对象头中有Mark Down （hashcode和锁信息） 和 Class Metadata Address （存储到对象类型数据的指针），如果是数组类型， 还有一个字段是数组长度

  每个字段都是1位（32/64bit）

* Mark Down

  * HashCode , 分带年龄和锁标记位，是否偏向锁
  * 锁又可以具体分为轻量级锁、重量级锁、偏向锁
  * 或者是GC标记

#### 2.2.2 锁的升级和对比

* 为了优化性能节省消耗----> 出现了偏向锁和轻量级锁

* 锁的状态： 无锁 -----> 偏向锁 -----> 轻量级锁---->重量级锁。锁的状态可生不可降，为了提高获取、释放锁的效率

* 偏向锁：

  ```
  大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
  ```

  

  * 撤销：

    ```
    偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
    ```

* 轻量级锁

  * 加锁

    ```
    线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
    ```

  * 解锁

    ```
    轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。图2-2是两个线程同时争夺锁，导致锁膨胀的流程图。
    因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。
    ```

  锁的对比：

  * 偏向锁：
    * 优点：加解锁无额外消耗
    * 如果有线程竞争，会带来额外的所撤销的消耗
    * 适用于一个线程访问的同步块
  * 轻量级锁：
    * 优点：竞争的线程不会阻塞
    * 缺点： 如果始终竞争不到，一直自选，会消耗CPU
    * 适用于追求相应时间，同步块执行速度很快
  * 偏向锁：
    * 优点：线程不使用自选，不会消耗CPU
    * 缺点：线程阻塞，相应时间慢
    * 适用于追求吞吐量，同步块执行速度较长