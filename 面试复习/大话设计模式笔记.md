# 大话设计模式笔记

## 简单工厂模式

### 总结：

*  基类（抽象类）中存放抽象方法，用于继承实现，实际的有好几个类，将抽象方法以不同的形式实现。
* 再搞一个工厂类，根据输入不同（switch ....case），返回不同实例

### UML类图

* 类分三层：名字（如果是抽象，斜体字）， 特性（属性、字段），操作（方法、行为）
* 接口图：名字上方有<<interface>>表示，第二行是接口方法。也有第二种棒棒糖表示法
* 继承：空心三角形+ 实线
* 实现接口： 空心三角形+ 虚线
* 关联
* 包含
* 组合
* 依赖







### 策略模式

* 总结： 是针对算法的，定义了算法家族，并封装起来，之间可以互换，根据输入的策略不同，可以调用不同的算法

### 单一职责原则

* 就一个类而言，应该仅有一个引起它变化的原因





### 开放-封闭原则

* 软件实体应该可以扩展、但是不可修改







### 依赖倒转原则

* 出现不应该依赖细节，细节应该依赖于抽象
* 即针对接口编程，不要对实现编程
* 高层模块不应该依赖底层模块，两个都应该依赖抽象





### 里氏代换原则

* 一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别
* 在软件里面，把父类都替换成它的子类，程序的行为没有变化。
* 只有当子类可以替换掉父类，软件的单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。









### 装饰模式



* 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
* 将每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时更具需要有选择的、按顺序的使用装饰功能包装对象
* 将类的核心职责和装饰功能区分开。







### 代理模式

* 为其他对象提供一种代理以控制对这个对象的访问
* 应用：
  * 远程代理： 为一个对象在不同的地址空间提供局部代理，隐藏一个对象存在于不同地址空间的事实
  * 虚拟代理： 根据需要，创建开销很大的对象。（浏览器图片加载，先创建空间，内容慢慢加载）
  * 安全代理： 控制真实对象的访问权限
  * 智能指引： 当调用真实的对象时，代理处理另外一些事情







### 迪米特法则

* 最少知识原则
* 如果两个类不必直接彼此通信，就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法的话，可以通过第三者转发这个调用。
* 就是松耦合







### 外观模式

* 为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口是的这一子系统更加容易使用。
* 类似一个关口，上层调用只关注这个关口，具体的逻辑实现，由关口和其背后的逻辑实现。也是解耦



### 工厂方法

* 简单工厂模式的最大优点：工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖
* 工厂方法： 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。







### 原型模式

* 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
* 其实就是从一个对象再创建另一个可定制的对象，而且不需要知道任何创建的细节
* 深浅复制：
  * 浅复制： 值复制、引用不复制
  * 深复制，引用指向新的对象





### 模板方法模式

* 当要完成某一细节层次一致的一个过程或一些列步骤，但个别步骤在更详细的层次上的实现可能不同时，通常考虑也能够模板方法模式来处理。
* 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构，即可重定义该算法的某些特定步骤

### 迪米特法则

* 在类的结构设计上，每一个类都应当尽量降低成员的访问权限
* 迪米特法则根本思想，是强调类之间的松耦合。

### 外观模式

* 为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

* 实际上就是一个关口，关外的命令只关注关口。关口内的情况只有关口内的人关心







### 建造者模式

* 将一个复杂对象的构建和他的标表示分离，使得同样的构建过程可以创建不同的表示。
* 用户只需要指定需要建造的类型就可以的得到他们，不需要知道具体建造的过程和细节

* 指挥者，抽象接口，具体建造者
* 用于创建一些复杂的对象，这些对象内部构造键的建造顺序通常是稳定的，但是对象内部的构建通常面临复杂的变化。
* 使建造代码与表示代码分离

### 观察者模式

* 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主体对象在状态发生变化时，会通知所有观察者，让他们能够自动更新自己。
* 观察者模式其实就是在解耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化，都不会影响另一边的变化。







### 抽象工厂模式

* 提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类
* 优点： 易于交换产品系列，由于具体工厂类，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变的十分容易，它只需要改变具体工厂接口使用不同的产品配置
* 让具体的创建实例的过程和客户端分离。
* 进一步可以使用反射技术，使之更灵活的创建实例
* 相较于工厂模式的区别：多了一个抽象产品的接口，来承担实例不同工厂生产的具体产品





### 状态模式

* 当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到鄙视不同状态的一系列类中，可以把复杂的判断逻辑简单化
* 将与特定状态相关的行为局部化，并且将不同的状态的行为分割开来
* 实际上就是状态先分成大类，然后在类别中进行小的判断，与状态转移





### 适配器模式

* 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作
* 系统的数据和行为都正确，但是接口不符时，我们应该考虑使用适配器，目的是是限制范围之外的一个原有对象和接口匹配。适配器模式主要应用于希望复用一些现存类的情况
* 感觉和装饰器模式类似，区别是装饰器的重点是灵活添加更多的功能，突出一个组合。适配器是套一层后，使内外接口不一致的情况下也能工作。适配才是重点。





### 备忘录模式

* 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。







### 组合模式

* 将对象组合成树形结构以表示“部分---整体”的层次结构。组合模式使得用户对的那个对象和组合对象的使用具有一致性。
* 分有透明模式和安全模式，就是结构分形自相似，想像成树就对了，需要分树中节点和叶子节点









### 迭代器模式

* 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露对该对象的内部表示







### 单例模式

* 保证一个类仅有一个实例，并提供一个访问它的全局访问点
* 类自身负责保存它的唯一实例
* 所有的类都会有构造方法，不编码则系统默认生成空的构造方法，如果有显式定义的构造方法，默认的就会失效

* 双重锁定

  先判断实例是否存在，如果不存在，再加锁处理，之后在判断是否存在实例，然后再决定是否创建实例

* 饿汉/ 懒汉





### 桥接模式

* 合成/聚合复用原则，尽量使用合成/聚合，尽量不要使用类继承
* 桥接模式，将抽象部分与它的实现部分分离，使他们都可以独立的变化
* 系统可能有多角度分类每一种都有可能变化，那么就把这中多角度分离出来，让他们独立变化，减少其耦合。





### 命令模式

* 将一个请求封装为一个对象，从而是只可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作





### 责任链模式

* 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止







### 中介者模式

* 用一个中介对象来封装一系列的对象交互。中介者使对象不需要显式地相互引用，从而使其耦合送死啊，而且可以独立的改变它们之间的交互。
* 中介者可能会变的十分复杂



### 享元模式

* 运用共享技术有效地支持大量细粒度的对象